

# This file was *autogenerated* from the file ex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_130 = Integer(130); _sage_const_5 = Integer(5); _sage_const_32 = Integer(32); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16); _sage_const_0x0ffffffc0ffffffc0ffffffc0fffffff = Integer(0x0ffffffc0ffffffc0ffffffc0fffffff); _sage_const_240 = Integer(240); _sage_const_10 = Integer(10); _sage_const_13 = Integer(13); _sage_const_100 = Integer(100); _sage_const_128 = Integer(128); _sage_const_1 = Integer(1); _sage_const_106 = Integer(106); _sage_const_26 = Integer(26); _sage_const_0x5000000 = Integer(0x5000000); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_116 = Integer(116); _sage_const_30 = Integer(30); _sage_const_3 = Integer(3); _sage_const_20 = Integer(20); _sage_const_22 = Integer(22); _sage_const_24 = Integer(24); _sage_const_21 = Integer(21); _sage_const_135 = Integer(135); _sage_const_234 = Integer(234); _sage_const_210 = Integer(210); _sage_const_104 = Integer(104); _sage_const_500 = Integer(500); _sage_const_251 = Integer(251)
import random
import os
from Crypto.Hash import Poly1305
from Crypto.Cipher import ChaCha20
from tqdm import trange

TEST = False

dat = ['b19dd2', 'aa43fc', '2ff840', 'f944d4', 'e383bf', 'e8ff57', '2c3cad', '70bdad', 'cc8f65', '59a2c1', '51521b', 'b11505', '71bf95', '76bd04', '190e9e', '22a76c', '4f4b46', '0b0366', '6e5b74', '683d66', '0df575', '697683', '91a11f', '2c4a88', 'b40c52', '9fec93', '3ea23e', '64dab3', 'a66cca', 'ca0c19', 'd93c0a', '9fee90', 'fd1fb8', '4eeb7b', 'b0f7ed', 'f19fe4', '26d00e', 'f34a69', '1e988c', 'c25981', 'd9769d', '45c5f6', 'a1e567', 'e9a267', 'bad1bb', 'a93814', '76dfa1', 'd1654d', 'bee544', 'c4411e', 'b85110', 'fe920e', 'becb14', '3bc932', '932bac', '79b1a4', '5c4a1f', 'de129a', 'e4a860', '843b24', '0ea4e2', 'b8cfc0', '0e3430', 'f4b9b6', '1b4e1c', 'ba5b9b', '08265b', '864033', 'b608a8', '528292', 'b584de', 'f5a8d7', 'd1755e', 'da6933', 'dd4d1c', '535056', 'afdbf7', '851752', '88c665', '96767b', 'a08d9c', '32fba1', '0908c4', '89988f', '14d67f', 'ba2351', '8e61e8', '0dd35b', '4d9602', '9d856f', '243164', 'da0d61', 'ac1f97', '93b4b1', '48e574', '1d5541', 'c07b6a', 'ab87a2', 'dab5f2', '2696a5', '8131d0', 'af1274', 'e708a5', '86cc20', '27f6e5', '25561e', '184d0b', 'f4a48c', '7f42ae', '3669ec', 'cb2cd9', 'ca3bd7', 'c2ac38', 'd369c9', '3d11db', '0f46eb', 'd93f87', '8c55dc', '95f747', 'a75315', '852372', '84ffdb', '94d2c7', '9e3b85', 'c2bbad', 'dfb4e8', '311889', 'dcc5e6', '7eb10f', '59dffc', '1957a8', 'df10b3', 'ebfd25', 'fa1c6e', 'fe5802', '909042', 'aba5bf', 'db1403', 'acd4d7', '5ec9c6', 'e35e93', '0e0735', '77c6ca', '05a40e', 'b1b21b', '439f40', '6b5c30', '98e5c2', '1428df', '61726d', 'f6a253', '175142', 'd18960', 'ec8811', '5f1daa', '4c7d05', '92da84', '67c25c', '4967e9', '22c20e', 'ad68ef', '6523a7', '9dacd4', 'eb3b78', '4bf3dc', '020b44', '8bda25', 'f514ed', 'bc59b4', '59fba2', '9849c0', '547f6a', '4fa5f8', '6db1c8', '1ae1ba', '446db3', '1e9321', '2d966c', '93ade6', '8bc51b', '3a3e1a', '69c550', '8461c5', 'a1bc1c', '968377', '560eaa', 'e2f7be', '49e8cd', '3eaebc', '82729b', 'ed6bd4', '2d0b4f', '9ab070', '8e4610', '7545e9', '535e09', '6ed07d', '06a370', '2eb836', 'a4420d', 'c55236', 'fe9434', '44ed45', '4eb761', '193dbe', '8b8e4d', '1b1c78', 'fa05bb', 'f259d5', 'bcf9c7', '250f78', 'e3f928', '2e6c84', '34bab5', 'aacbf7', '837b84', '7b26be', '44693d', '2f1d0d', '106705', '3c9b72', 'f07768', '01bba5', 'ace1cf', '3344cc', 'a802bd', '77c9f8', '7da7ef', 'ebbf7d', '1cf462', 'b97592', '039f98', '6cdecf', '4a2c7b', 'bd8209', '2bfb88', '0bd392', '85a9be', 'c5c893', '1fc88e']
dat = [int.from_bytes(bytes.fromhex(d), "little") for d in dat]

p = _sage_const_2 **_sage_const_130  - _sage_const_5 
assert is_prime(p)

key, nonce = os.urandom(_sage_const_32 ), os.urandom(_sage_const_8 )
st = os.urandom(_sage_const_16 )
rs = ChaCha20.new(key=key, nonce=nonce).encrypt(b'\x00' * _sage_const_32 )
r, s = rs[:_sage_const_16 ], rs[_sage_const_16 :]
r = int.from_bytes(r, "little")
s = int.from_bytes(s, "little")
r &= _sage_const_0x0ffffffc0ffffffc0ffffffc0fffffff 

def poly1305_hash(data):
	hsh = Poly1305.new(key=key, cipher=ChaCha20, nonce=nonce)
	hsh.update(data=data)
	return hsh.digest()

ps = []
real = []

n = _sage_const_240 

if TEST:
	for i in range(n):
		ps.append(int.from_bytes(st[_sage_const_10 :_sage_const_13 ], "little"))
		real.append(int.from_bytes(st, "little"))

		st = poly1305_hash(st)
else:
	ps = dat

if TEST:
	for i in range(_sage_const_100 ):
		tst = (real[i] + _sage_const_2 **_sage_const_128 ) * r % p
		tst += s
		tst %= _sage_const_2 **_sage_const_128 
		assert tst == real[i + _sage_const_1 ]

reals = []
Ps = []
for i in range(n - _sage_const_1 ):
	P = _sage_const_2 **_sage_const_106  * (ps[i] - ps[i + _sage_const_1 ]) % p
	Ps.append(P)
	# print(hex(P))

	if TEST:
		Pr = _sage_const_2 **_sage_const_26  * (real[i] - real[i + _sage_const_1 ]) % p
		reals.append(Pr)

		# print(hex(Pr))
		assert abs(Ps[i] - reals[i]).bit_length() <= _sage_const_106 
		# print(abs(P - Pr).bit_length())
# exit()

if TEST:
	diffs = []

	for i in range(n - _sage_const_2 ):
		diff = reals[i] * r % p - reals[i + _sage_const_1 ]
		# print(hex(diff))
		assert diff % _sage_const_0x5000000  == _sage_const_0 
		diff //= _sage_const_0x5000000 
		assert diff in range(-_sage_const_4 , _sage_const_5 )

		diffs.append(diff)

	rr = r

cnt = _sage_const_0 

MM = []
real_Ps = Ps[:]

bss = []

for i in range(_sage_const_2 ):
	base = _sage_const_116  * i


	size = _sage_const_30 
	l = size * _sage_const_4  - _sage_const_2 
	r = _sage_const_3  * size
	d = size

	M = Matrix(r + d, r + d)

	for i in range(r):
		M[i, i] = _sage_const_2 **_sage_const_106 

	for i in range(d):
		M[r + i, r + i] = p

	for i in range(r):
		for j in range(d):
			M[i, r + j] = Ps[base + i + j]

	M = M.LLL()


	v = M[_sage_const_0 ][:r]
	v = [k // _sage_const_2 **_sage_const_106  for k in v]

	MM = []

	def dot(aa, bb):
		assert len(aa) == len(bb)
		res = _sage_const_0 
		for a, b in zip(aa, bb):
			res += a * b
		return res

	for i in range(size - _sage_const_1 ):
		v = M[i][:r]
		v = [k // _sage_const_2 **_sage_const_106  for k in v]

		# print(hex(dot(v, reals[i:i + r]) % p))
		for t in range(size - _sage_const_1 ):
			if TEST:
				# print(dot(v, reals[t + base:t + r + base]) % p)
				assert dot(v, reals[t + base:t + r + base]) % p == _sage_const_0 
			cnt += _sage_const_1 

			app = [_sage_const_0 ] * t + v
			app += [_sage_const_0 ] * (l - len(app))
			MM.append(app)

	MM = Matrix(GF(p), MM)
	bs = MM.right_kernel().basis()
	assert len(bs) == _sage_const_1 
	bs = bs[_sage_const_0 ]
	if TEST:
		aa = (bs * reals[_sage_const_0  + base])[:_sage_const_20 ]
		for i in range(_sage_const_20 ):
			assert aa[i] == reals[i + base]

	M = Matrix(_sage_const_22 , _sage_const_22 )
	for i in range(_sage_const_20 ):
		M[_sage_const_0 , i] = ZZ(bs[i]) * _sage_const_2 **_sage_const_24 
		M[i + _sage_const_1 , i] = p * _sage_const_2 **_sage_const_24 
		M[_sage_const_21 , i] = Ps[i + base] * _sage_const_2 **_sage_const_24 


	wt = _sage_const_2 **_sage_const_135 
	M[_sage_const_0 , _sage_const_20 ] = _sage_const_1 
	M[_sage_const_21 , _sage_const_21 ] = wt

	M = M.LLL()
	for v in M:
		if v[_sage_const_21 ] == wt:
			break
	else:
		print("no")
		exit()

	bs = -bs * v[_sage_const_20 ]
	bs = [ZZ(k) % p for k in bs]

	# print(len(bs))
	bss.append(bs)

assert bss[_sage_const_0 ][-_sage_const_2 :] == bss[_sage_const_1 ][:_sage_const_2 ]
# print(bss)
bs = bss[_sage_const_0 ] + bss[_sage_const_1 ][_sage_const_2 :]

if TEST:
	assert bs[:_sage_const_10 ] == reals[:_sage_const_10 ]

# print(len(bs))
assert len(bs) == _sage_const_234 

pos = None

for i in range(_sage_const_10 ):
	ss = set()
	for j in range(-_sage_const_4 , _sage_const_5 ):
		pp = ((bs[i + _sage_const_1 ] + j * _sage_const_0x5000000 ) / bs[i]) % p
		ss.add(pp)
	if pos == None:
		pos = ss
	else:
		pos = pos & ss

assert len(pos) == _sage_const_1 
# print(pos)
r_final = pos.pop()
# print(r_final)

if TEST:
	assert rr == r_final

assert r_final & _sage_const_0x0ffffffc0ffffffc0ffffffc0fffffff  == r_final
r = r_final
# print(r_final)

bs = [(-k * pow(_sage_const_2 , -_sage_const_26 , p)) % p for k in bs]

Ps = real_Ps

assert len(bs) == _sage_const_234 








toadd = []

todolen = _sage_const_210 
bs = bs[:todolen]

for i in range(todolen):
	toadd.append(sum(bs[:i]) % p)

if TEST:
	for i in range(todolen):
		assert (toadd[i] + real[_sage_const_0 ]) % p == real[i]




if TEST:
	s0 = s % _sage_const_2 **_sage_const_104 
	sa = s >> _sage_const_104 
	assert s == _sage_const_2 **_sage_const_104  * sa + s0
else:
	init = '4b2b8f015ac838013b2330496b'
	init = bytes.fromhex(init)
	init = int.from_bytes(init, "little")
	s0 = init - (((int.from_bytes(b"init\x01", "little") * r) % p) % _sage_const_2 **_sage_const_104 )

vvs = set()

for i in range(todolen - _sage_const_1 ):
	vv = toadd[i + _sage_const_1 ] - (_sage_const_2 **_sage_const_128  + toadd[i]) * r - s0
	vv %= p
	vvs.add(vv)

assert len(vvs) == _sage_const_5 

for vv in vvs:
	if ((vv - _sage_const_5 ) % p) in vvs:
		break

if TEST:
	assert (real[_sage_const_0 ] * (r - _sage_const_1 ) + _sage_const_2 **_sage_const_104  * sa - vv) % p == _sage_const_0 



rrs = [_sage_const_0 ] * _sage_const_500 

cnt = _sage_const_0 

flagenc = '4a1891d571e9f122afcc0203d0aeeda9e66bc125df5c883e84fd6eeef23ecefc4efeacd0a612'
ct = bytes.fromhex(flagenc)

for saa in trange(_sage_const_2 **_sage_const_24 ):
	# saa = sa
	mys = s0 + _sage_const_2 **_sage_const_104  * saa
	t = (vv - _sage_const_2 **_sage_const_104  * saa) / (r - _sage_const_1 )
	t %= p

	# assert mys == s
	# assert t == real[0]
	
	fail = False
	for i in range(todolen):
		# print(f"{i = }")
		rrs[i] = (t + toadd[i]) % p

		# print(rrs[0].bit_length())

		if rrs[i] >= _sage_const_2 **_sage_const_128 :
			fail = True
			break

		
		if i >= _sage_const_1 :
			# assert rrs[i] == real[i]
			# assert rrs[i - 1] == real[i - 1]

			tst = (rrs[i - _sage_const_1 ] + _sage_const_2 **_sage_const_128 ) * r % p
			tst += mys
			tst %= _sage_const_2 **_sage_const_128 
			if rrs[i] != tst:
				fail = True
				break
		
	if fail:
		continue

	for i in range(todolen, todolen + _sage_const_100 ):
		prev = rrs[i - _sage_const_1 ]
		res = (prev + _sage_const_2 **_sage_const_128 ) * r % p
		res += mys
		res %= _sage_const_2 **_sage_const_128 
		rrs[i] = res

	cnt += _sage_const_1 
	# print(cnt)

	fin = rrs[_sage_const_240 :_sage_const_251 ]
	fin = [int(kk).to_bytes(_sage_const_16 , "little")[_sage_const_10 :_sage_const_13 ] for kk in fin]
	key = b"".join(fin)[:_sage_const_32 ]

	
	cipher = ChaCha20.new(key=key, nonce=b'\0'*_sage_const_8 )
	pt = cipher.decrypt(ct)

	if b"mar" in pt:
		print(pt)
		break


