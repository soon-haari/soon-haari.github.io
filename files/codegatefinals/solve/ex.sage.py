

# This file was *autogenerated* from the file ex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_17776 = Integer(17776); _sage_const_100000 = Integer(100000); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_2 = Integer(2); _sage_const_25 = Integer(25); _sage_const_24 = Integer(24); _sage_const_2411 = Integer(2411); _sage_const_83 = Integer(83); _sage_const_1000000 = Integer(1000000); _sage_const_100 = Integer(100); _sage_const_170 = Integer(170); _sage_const_166 = Integer(166); _sage_const_8501 = Integer(8501); _sage_const_2125 = Integer(2125); _sage_const_4252 = Integer(4252); _sage_const_6376 = Integer(6376); _sage_const_4251 = Integer(4251); _sage_const_8500 = Integer(8500); _sage_const_4250 = Integer(4250)
from pwn import *
from tqdm import trange, tqdm
import hashlib


TEST = False

if TEST:
	io = process(["sage", "task.sage"])
else:
	io = remote("52.79.59.27", _sage_const_17776 )

sys.set_int_max_str_digits(_sage_const_100000 )

def decode_num(num, n):
	num_cp = num
	res = []
	for _ in range(n):
		res.append((num_cp % _sage_const_3 ) - _sage_const_1 )
		num_cp //= _sage_const_3 
	res.extend([_sage_const_0 ] * (n - len(res)))
	return res

def encode_num(n, arr):
    res = _sage_const_0 
    for i in range(n):
        assert -_sage_const_1  <= arr[i] <= _sage_const_1 
        res += (arr[i] + _sage_const_1 ) * (_sage_const_3  ** i)
    return res 

def fmt3(n):
	return ((int(n) + _sage_const_1 ) % _sage_const_3 ) - _sage_const_1 

def solve_pow():
	pfx = bytes.fromhex(io.recvline()[:-_sage_const_1 ].decode())
	assert len(pfx) == _sage_const_8 
	for i in trange(_sage_const_2 **_sage_const_25 ):
		sfx = str(i)
		sfx = "0" * (_sage_const_24  - len(sfx)) + sfx
		sfx = sfx.encode()

		if hashlib.sha256(pfx + sfx).digest()[:_sage_const_3 ] == b"\x00" * _sage_const_3 :
			break

	io.sendline(bytes.hex(sfx))


if TEST == False:
	solve_pow()

def solve_task1():

	n, D = _sage_const_2411 , _sage_const_83 
	
	P = PolynomialRing(ZZ, 'x')
	x = P.gen()

	T = P.change_ring(GF(_sage_const_3 )).quotient(x ** n - _sage_const_1 )
	x = T.gen()

	if TEST:
		ffff = P(decode_num(int(io.recvline()[:-_sage_const_1 ]), n))
		ffff3 = P(decode_num(int(io.recvline()[:-_sage_const_1 ]), n))


		mul = T(ffff * ffff3)
		assert mul == _sage_const_1 

	sel1 = eval(io.recvline()[:-_sage_const_1 ])
	sel2 = eval(io.recvline()[:-_sage_const_1 ])

	f = decode_num(int(io.recvline()[:-_sage_const_1 ]), n)
	f3 = decode_num(int(io.recvline()[:-_sage_const_1 ]), n)
	assert len(f) == n and len(f3) == n

	# print(f.count(-1))
	# print(f.count(0) - 83)
	# print(f.count(1))

	for s in sel1:
		assert f[s] == _sage_const_0 

	for s in sel2:
		assert f3[s] == _sage_const_0 

	var_num = _sage_const_83  * _sage_const_2 
	M = []
	R = [_sage_const_0 ] * n
	R[_sage_const_0 ] = _sage_const_1 

	doubles = []
	for _ in range(n):
		M.append([_sage_const_0 ] * var_num)
		doubles.append([])


	for i in trange(n):
		for j in range(n):
			deg = (i + j) % n
			if i in sel1 and j in sel2:
				doubles[deg].append([sel1.index(i), sel2.index(j)])
				continue

			elif i in sel1:
				M[deg][sel1.index(i)] += f3[j]

			elif j in sel2:
				M[deg][sel2.index(j) + D] += f[i]
			
			else:
				R[deg] -= f[i] * f3[j]

	zero = []
	one = []
	for i in range(n):
		if len(doubles[i]) == _sage_const_0 :
			zero.append(i)
		if len(doubles[i]) == _sage_const_1 :
			one.append(i)

	cnt = [_sage_const_0 ] * _sage_const_83 

	# print(len(zero), len(one))

	for i in one:
		cnt[doubles[i][_sage_const_0 ][_sage_const_0 ]] += _sage_const_1 

	cnt = [cnt[i] * _sage_const_1000000  + i for i in range(_sage_const_83 )]

	cnt.sort()

	for i in range(_sage_const_1 , _sage_const_100 ):
		# print(f"asdf {i}")
		tot = len(zero)
		for k in cnt[-i:]:
			tot += k // _sage_const_1000000 
			tot += _sage_const_1 

		if tot >= _sage_const_170 :
			# print(tot)
			known = tot
			bf = i
			break

	bfs = [k % _sage_const_1000000  for k in cnt[-bf:]]

	# print(bf)

	print(bfs)

	bf = len(bfs)


	M_default = []
	res_default = []

	for i in range(n):
		if i in zero:
			M_default.append(M[i])
			res_default.append(R[i])

	print(len(M_default))

	

	if TEST:

		correct_root = vector(GF(_sage_const_3 ), [ffff[t] for t in sel1] + [ffff3[t] for t in sel2])

		assert T(ffff) * T(ffff3) == _sage_const_1 

		roots = vector(GF(_sage_const_3 ), [correct_root[k] for k in bfs])

		to_add_M = []
		to_add_res = []

		for i in range(bf):
			a = [_sage_const_0 ] * _sage_const_166 
			a[bfs[i]] = _sage_const_1 
			
			to_add_M.append(a)
			to_add_res.append(roots[i])

		for i in range(n):
			if i not in one:
				continue

			a = doubles[i][_sage_const_0 ][_sage_const_0 ]
			b = doubles[i][_sage_const_0 ][_sage_const_1 ]

			# print(a, b)

			if a not in bfs:
				continue

			k = bfs.index(a)

			mm = M[i][:]

			mm[b + D] += roots[k]
			assert len(mm) == _sage_const_166 
			to_add_M.append(mm)
			to_add_res.append(R[i])

		MM = Matrix(GF(_sage_const_3 ), M_default + to_add_M)
		RRR = vector(GF(_sage_const_3 ), res_default + to_add_res)

		# assert len(MM) == len(RRR) == known

		root = MM.solve_right(RRR)

		assert root == correct_root
		print(root)
		print(correct_root)
		print()

		f_scene = f[:]
		f3_scene = f3[:]

		for i in range(_sage_const_83 ):
			f_scene[sel1[i]] = fmt3(root[i])
			f3_scene[sel2[i]] = fmt3(root[i + D])


		if T(f_scene) * T(f3_scene) == _sage_const_1 :
			print("FUCK YEAH")



	sent = False

	for it in trange(_sage_const_3 **bf):
		it_ = it
		roots = []
		for i in range(bf):
			roots.append((it_ % _sage_const_3 ) - _sage_const_1 )
			it_ //= _sage_const_3 

		to_add_M = []
		to_add_res = []

		for i in range(bf):
			a = [_sage_const_0 ] * _sage_const_166 
			a[bfs[i]] = _sage_const_1 
			
			to_add_M.append(a)
			to_add_res.append(roots[i])

		for i in range(n):
			if i not in one:
				continue

			a = doubles[i][_sage_const_0 ][_sage_const_0 ]
			b = doubles[i][_sage_const_0 ][_sage_const_1 ]

			# print(a, b)

			if a not in bfs:
				continue

			k = bfs.index(a)

			mm = M[i][:]

			mm[b + D] += roots[k]
			assert len(mm) == _sage_const_166 
			to_add_M.append(mm)
			to_add_res.append(R[i])

		MM = Matrix(GF(_sage_const_3 ), M_default + to_add_M)
		RRR = vector(GF(_sage_const_3 ), res_default + to_add_res)

		# assert len(MM) == len(RRR) == known

		try:
			root = MM.solve_right(RRR)

			# print(root)
			# print(correct_root)
			# print()


		except:
			continue

		if TEST:
			chk = True
			for k in bfs:
				if GF(_sage_const_3 )(root[k]) != GF(_sage_const_3 )(correct_root[k]):
					chk = False

			if chk:
				print(correct_root)
				print(root)
				assert correct_root == root

		f_scene = f[:]
		f3_scene = f3[:]

		for i in range(_sage_const_83 ):
			f_scene[sel1[i]] = fmt3(root[i])
			f3_scene[sel2[i]] = fmt3(root[i + D])

		if T(f_scene) * T(f3_scene) == _sage_const_1 :
			# print("FUCK YEAH")
			io.sendline(str(encode_num(n, f_scene)))
			io.sendline(str(encode_num(n, f3_scene)))

			sent = True

			break

	if sent == False:
		print("UNnlucky fuck")
		exit()






def solve_task2():
	n, D = _sage_const_8501 , _sage_const_2125 
	seed_str = open("seed.txt", "rb").read()
	seed = int(seed_str)

	import random

	random.seed(seed)

	sel = set(range(n - D, n))

	assert sel == set(random.sample(range(n), D))
	assert sel == set(random.sample(range(n), D))


	io.sendline(seed_str)

	assert sel == set(eval(io.recvline()))
	assert sel == set(eval(io.recvline()))

	f = decode_num(int(io.recvline()[:-_sage_const_1 ]), n)
	f3 = decode_num(int(io.recvline()[:-_sage_const_1 ]), n)

	assert f[-D:] == [_sage_const_0 ] * D
	assert f3[-D:] == [_sage_const_0 ] * D

	M = []
	for _ in range(_sage_const_4252 ):
		M.append([_sage_const_0 ] * D * _sage_const_2 )
	r = [_sage_const_0 ] * _sage_const_4252 
	r[_sage_const_0 ] = _sage_const_1 

	unk = set(range(_sage_const_6376 , _sage_const_8501 ))

	for i in trange(_sage_const_4251 ):
		for j in range(n):
			a, b = j, (i - j) % n
			if a in unk and b in unk:
				print("Fuck")
				exit()

			elif a in unk:
				M[i][a - _sage_const_6376 ] += f3[b]
			elif b in unk:
				M[i][b - _sage_const_6376  + D] += f[a]
			else:
				r[i] -= f[a] * f3[b]

	for j in range(n):
		a, b = j, (_sage_const_8500  - j) % n
		if a in unk and b in unk:
			print("Fuck")
			exit()

		elif a in unk:
			M[_sage_const_4251 ][a - _sage_const_6376 ] += f3[b]
		elif b in unk:
			M[_sage_const_4251 ][b - _sage_const_6376  + D] += f[a]
		else:
			r[_sage_const_4251 ] -= f[a] * f3[b]


	M = Matrix(GF(_sage_const_3 ), M)
	r = vector(GF(_sage_const_3 ), r)

	root = M.solve_right(r)

	rk = M.rank()

	if rk != _sage_const_4250 :
		print("Fuckfuck")
		exit()

	for i in range(_sage_const_2125 ):
		f[i + _sage_const_6376 ] = fmt3(root[i])
		f3[i + _sage_const_6376 ] = fmt3(root[i + D])

	f_num = encode_num(n, f)
	f3_num = encode_num(n, f3)

	io.sendline(str(f_num))
	io.sendline(str(f3_num))

	

for _ in range(_sage_const_8 ):
	print(f"Round {_ + _sage_const_1 }")
	solve_task1()

for _ in range(_sage_const_8 ):
	print(f"Round {_ + _sage_const_1 }")
	solve_task2()

io.interactive()

