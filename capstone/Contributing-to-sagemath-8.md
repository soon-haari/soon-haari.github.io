---
layout: post
category: capstone
title: "Contributing to SageMath (팀 \"이태관\"(중요))"
permalink: c8
---

For capstone class(2025/5/9).

## Goals
1. Fix XGCD implementations to use PARI
2. Fix `inverse_mod`, so that it calls appropriate XGCD
3. Profit

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Goal 1. Fix XGCD implementations

#### Last week's Conclusion

- **FLINT** is fine.
- **NTL**'x XGCD for prime modulus can be improved using PARI.
- **NTL**'x GCD/XGCD isn't implemented and can be written using PARI.

Next week plans:
- Find NTL's GCD/XGCD for composite Zmod, and write my new implementations with PARI.
- ~~And maybe make a PR...~~

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Digging into NTL's GCD/XGCD

#### 1. Prime modulus NTL

```sh
sage: P.<x> = PolynomialRing(GF(7), implementation='NTL')
sage: x.gcd??
```

Implemented in `sage/rings/polynomial/polynomial_modn_dense_ntl.pyx`

```python
@coerce_binop
def gcd(self, right):
    """
    Return the greatest common divisor of this polynomial and ``other``, as
    a monic polynomial.

    INPUT:

    - ``other`` -- a polynomial defined over the same ring as ``self``

    EXAMPLES::

        sage: R.<x> = PolynomialRing(GF(3), implementation="NTL")
        sage: f, g = x + 2, x^2 - 1
        sage: f.gcd(g)
        x + 2
    """
    g = self.ntl_ZZ_pX().gcd(right.ntl_ZZ_pX())
    return self.parent()(g, construct=True)

@coerce_binop
def xgcd(self, other):
    r"""
    Compute the extended gcd of this element and ``other``.

    INPUT:

    - ``other`` -- an element in the same polynomial ring

    OUTPUT:

    A tuple ``(r,s,t)`` of elements in the polynomial ring such
    that ``r = s*self + t*other``.

    EXAMPLES::

        sage: R.<x> = PolynomialRing(GF(3), implementation='NTL')
        sage: x.xgcd(x)
        (x, 0, 1)
        sage: (x^2 - 1).xgcd(x - 1)
        (x + 2, 0, 1)
        sage: R.zero().xgcd(R.one())
        (1, 0, 1)
        sage: (x^3 - 1).xgcd((x - 1)^2)
        (x^2 + x + 1, 0, 1)
        sage: ((x - 1)*(x + 1)).xgcd(x*(x - 1))
        (x + 2, 1, 2)
    """
    r, s, t = self.ntl_ZZ_pX().xgcd(other.ntl_ZZ_pX())
    return self.parent()(r, construct=True), self.parent()(s, construct=True), self.parent()(t, construct=True)
```

#### 2. Composite modulus NTL

```sh
sage: P.<x> = PolynomialRing(Zmod(6), implementation='NTL')
sage: x.gcd??
```

Implemented in `sage/rings/polynomial/polynomial_element.pyx`

```python
@coerce_binop
def gcd(self, other):
    """
    Return a greatest common divisor of this polynomial and ``other``.

    INPUT:

    - ``other`` -- a polynomial in the same ring as this polynomial

    OUTPUT:

    A greatest common divisor as a polynomial in the same ring as
    this polynomial. If the base ring is a field, the return value
    is a monic polynomial.

    .. NOTE::

        The actual algorithm for computing greatest common divisors depends
        on the base ring underlying the polynomial ring. If the base ring
        defines a method :meth:`_gcd_univariate_polynomial`, then this method
        will be called (see examples below).

    EXAMPLES::

        sage: R.<x> = QQ[]
        sage: (2*x^2).gcd(2*x)
        x
        sage: R.zero().gcd(0)
        0
        sage: (2*x).gcd(0)
        x

    One can easily add gcd functionality to new rings by providing a method
    ``_gcd_univariate_polynomial``::

        sage: # needs sage.rings.number_field sage.symbolic
        sage: O = ZZ[-sqrt(5)]
        sage: R.<x> = O[]
        sage: a = O.1
        sage: p = x + a
        sage: q = x^2 - 5
        sage: p.gcd(q)
        Traceback (most recent call last):
        ...
        NotImplementedError: Order of conductor 2 generated by a in Number
        Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
        does not provide a gcd implementation for univariate polynomials
        sage: S.<x> = O.number_field()[]
        sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
        sage: p.gcd(q)
        x + a
        sage: del O._gcd_univariate_polynomial

    Use multivariate implementation for polynomials over polynomials rings::

        sage: R.<x> = ZZ[]
        sage: S.<y> = R[]
        sage: T.<z> = S[]
        sage: r = 2*x*y + z
        sage: p = r * (3*x*y*z - 1)
        sage: q = r * (x + y + z - 2)
        sage: p.gcd(q)                                                              # needs sage.libs.singular
        z + 2*x*y

        sage: R.<x> = QQ[]
        sage: S.<y> = R[]
        sage: r = 2*x*y + 1
        sage: p = r * (x - 1/2 * y)
        sage: q = r * (x*y^2 - x + 1/3)
        sage: p.gcd(q)                                                              # needs sage.libs.singular
        2*x*y + 1

    TESTS::

        sage: Pol = QQ['x','y']['x']
        sage: Pol.one().gcd(1)
        1
    """
    cdef Polynomial _other = <Polynomial> other
    if _other.is_one():
        return other
    elif self.is_one():
        return self
    flatten = self._parent.flattening_morphism()
    tgt = flatten.codomain()
    if tgt.ngens() > 1 and tgt._has_singular:
        g = flatten(self).gcd(flatten(other))
        return flatten.section()(g)
    try:
        doit = self._parent._base._gcd_univariate_polynomial
    except AttributeError:
        raise NotImplementedError("%s does not provide a gcd implementation for univariate polynomials"%self._parent._base)
    else:
        return doit(self, other)

...

@coerce_binop
def xgcd(self, other):
    r"""
    Return an extended gcd of this polynomial and ``other``.

    INPUT:

    - ``other`` -- a polynomial in the same ring as this polynomial

    OUTPUT:

    A tuple ``(r, s, t)`` where ``r`` is a greatest common divisor
    of this polynomial and ``other``, and ``s`` and ``t`` are such
    that ``r = s*self + t*other`` holds.

    .. NOTE::

        The actual algorithm for computing the extended gcd depends on the
        base ring underlying the polynomial ring. If the base ring defines
        a method :meth:`_xgcd_univariate_polynomial`, then this method will be
        called (see examples below).

    EXAMPLES::

        sage: # needs sage.rings.number_field
        sage: R.<x> = QQbar[]
        sage: (2*x^2).gcd(2*x)
        x
        sage: R.zero().gcd(0)
        0
        sage: (2*x).gcd(0)
        x

    One can easily add xgcd functionality to new rings by providing a
    method :meth:`_xgcd_univariate_polynomial`::

        sage: R.<x> = QQ[]
        sage: S.<y> = R[]
        sage: h1 = y*x
        sage: h2 = y^2*x^2
        sage: h1.xgcd(h2)
        Traceback (most recent call last):
        ...
        NotImplementedError: Univariate Polynomial Ring in x over Rational Field
        does not provide an xgcd implementation for univariate polynomials
        sage: T.<x,y> = QQ[]
        sage: def poor_xgcd(f, g):
        ....:     ret = S(T(f).gcd(g))
        ....:     if ret == f: return ret, S.one(), S.zero()
        ....:     if ret == g: return ret, S.zero(), S.one()
        ....:     raise NotImplementedError
        sage: R._xgcd_univariate_polynomial = poor_xgcd
        sage: h1.xgcd(h2)
        (x*y, 1, 0)
        sage: del R._xgcd_univariate_polynomial
    """
    if hasattr(self.base_ring(), '_xgcd_univariate_polynomial'):
        return self.base_ring()._xgcd_univariate_polynomial(self, other)
    else:
        raise NotImplementedError("%s does not provide an xgcd implementation for univariate polynomials"%self.base_ring())
```

#### 3. Extension field NTL

```sh
sage: P.<x> = PolynomialRing(GF(3^5), implementation='NTL')
sage: x.gcd??
```

Implemented in `sage/rings/polynomial/polynomial_template.pxi`

```python
@coerce_binop
def gcd(self, Polynomial_template other):
    """
    Return the greatest common divisor of ``self`` and ``other``.

    EXAMPLES::

        sage: P.<x> = GF(2)[]
        sage: f = x*(x+1)
        sage: f.gcd(x+1)
        x + 1
        sage: f.gcd(x^2)
        x

    TESTS:

    Ensure non-invertible elements does not crash Sage (:issue:`37317`)::

        sage: R.<x> = Zmod(4)[]
        sage: f = R(2 * x)
        sage: f.gcd(f)
        Traceback (most recent call last):
        ...
        ValueError: leading coefficient must be invertible

    ::

        sage: f = x^2 + 3 * x + 1
        sage: g = x^2 + x + 1
        sage: f.gcd(g)
        Traceback (most recent call last):
        ...
        RuntimeError: FLINT gcd calculation failed
    """
    if celement_is_zero(&self.x, (<Polynomial_template>self)._cparent):
        return other
    if celement_is_zero(&other.x, (<Polynomial_template>self)._cparent):
        return self
    if celement_equal(&self.x, &other.x, (<Polynomial_template>self)._cparent):
        # note: gcd(g, g) "canonicalizes" the generator i.e. make polynomials monic
        # c.f. ring/ring.pyx:445
        return self.monic()

    cdef type T = type(self)
    cdef Polynomial_template r = <Polynomial_template>T.__new__(T)
    celement_construct(&r.x, (<Polynomial_template>self)._cparent)
    r._parent = (<Polynomial_template>self)._parent
    r._cparent = (<Polynomial_template>self)._cparent
    celement_gcd(&r.x, &(<Polynomial_template>self).x, &(<Polynomial_template>other).x, (<Polynomial_template>self)._cparent)
    #assert(r._parent(pari(self).gcd(pari(other))) == r)
    return r

@coerce_binop
def xgcd(self, Polynomial_template other):
    """
    Compute extended gcd of ``self`` and ``other``.

    EXAMPLES::

        sage: P.<x> = GF(7)[]
        sage: f = x*(x+1)
        sage: f.xgcd(x+1)
        (x + 1, 0, 1)
        sage: f.xgcd(x^2)
        (x, 1, 6)
    """
    if(celement_is_zero(&self.x, (<Polynomial_template>self)._cparent)):
        return other, self._parent(0), self._parent(1)
    if(celement_is_zero(&other.x, (<Polynomial_template>self)._cparent)):
        return self, self._parent(1), self._parent(0)

    cdef type T = type(self)
    cdef Polynomial_template r = <Polynomial_template>T.__new__(T)
    celement_construct(&r.x, (<Polynomial_template>self)._cparent)
    r._parent = (<Polynomial_template>self)._parent
    r._cparent = (<Polynomial_template>self)._cparent

    cdef Polynomial_template s = <Polynomial_template>T.__new__(T)
    celement_construct(&s.x, (<Polynomial_template>self)._cparent)
    s._parent = (<Polynomial_template>self)._parent
    s._cparent = (<Polynomial_template>self)._cparent

    cdef Polynomial_template t = <Polynomial_template>T.__new__(T)
    celement_construct(&t.x, (<Polynomial_template>self)._cparent)
    t._parent = (<Polynomial_template>self)._parent
    t._cparent = (<Polynomial_template>self)._cparent

    celement_xgcd(&r.x, &s.x, &t.x, &(<Polynomial_template>self).x, &(<Polynomial_template>other).x, (<Polynomial_template>self)._cparent)
    #rp, sp, tp = pari(self).xgcd(pari(other))
    #assert(r._parent(rp) == r)
    #assert(s._parent(sp) == s)
    #assert(t._parent(tp) == t)
    return r,s,t
```

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Summary

- `sage/rings/polynomial/polynomial_modn_dense_ntl.pyx`: Prime modulus PolynomialRing
- `sage/rings/polynomial/polynomial_element.pyx`: Composite modulus PolynomialRing
- `sage/rings/polynomial/polynomial_template.pxi`: Others
    - It uses `celement_gcd`, `celement_xgcd` function internally, not sure what they do...

#### Some tips for fixing SageMath
- You can edit `.py` files, then sage will directly act as those changes.
- However, you have to recompile files such as `.pyx` and `.pyi` since those are relaced to C/C++ and has to be compiled before use.
    - Recompile only specific part using: `sage -b sage/rings/polynomial/polynomial_element.pyx`

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Fix
- `sage/rings/polynomial/polynomial_modn_dense_ntl.pyx`
<img src="../../files/sagemath/modn.png" width="800"/>

- `sage/rings/polynomial/polynomial_element.pyx`
<img src="../../files/sagemath/element1.png" width="800"/>
<br>
<img src="../../files/sagemath/element2.png" width="800"/>

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Open issue

[https://github.com/sagemath/sage/issues/40016](https://github.com/sagemath/sage/issues/40016)
<img src="../../files/sagemath/issue.png" width="800"/>

### Problem Description

Polynomials defined on Rings with FLINT has gcd/xgcd method function well implemented, and internally uses half-gcd algorithm as well for fast calculation.

However, if the modulus exceeds 2^63 - 1, where we can't use FLINT and is forced to use NTL, there exists some improvements on these functions.

Specifically, there is no proper gcd/xgcd function implemented for polynomial rings with composite modulus using NTL.
In the case modulus is prime, gcd function is well implemented with half-gcd algorithm, however xgcd function does not use half-gcd algorithm and takes a long time for high degree polynomials.

### Proposed Solution

I suggest both of the cases can be solved using PARI's gcd function and gcdext function which properly implments half-gcd algorithm.

For example, assuming a and b are polynomials defined on the same base ring, the following works:
```python
P = a.parent()
g = P(a._pari_with_name().gcd(b._pari_with_name()))
s, t, r = a._pari_with_name().gcdext(b._pari_with_name())
s, t, r = map(P, [s, t, r])
```

Some things to note:
- Generally xgcd function's result r, s, t satisfies r = a*s + b*t, however gcdext function gives order differently so that return value s, t, r still satisfies r = a*s + b*t.
- The result of gcd is generally always in the monic form, but PARI's gcd/gcdext function still leaves a leading coefficient behind.



### Alternatives Considered

.

### Additional Information

I found that polynomial ring with extension fields has gcd/xgcd implemented, without the half-gcd algorithm.
PARI also supports extension fields' polynomial rings gcd/xgcd using half-gcd algorithm, which means it can be improved with PARI.

However, I looked at the gcd/xgcd function in `src/sage/rings/polynomial/polynomial_template.pxi`, and found out it internally calls celement_gcd/celement_xgcd functions, and I wasn't exactly sure how to fix in this case, would be grateful if someone gives an idea or fix themselves.

This is my first time issuing or PR for SageMath, so please tell me if I'm doing something wrong or breaking the unspoken rule of SageMath society, thanks!!

### Is there an existing issue for this?

- [x] I have searched the existing issues for a bug report that matches the one I want to file, without success.

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Open PR

[https://github.com/sagemath/sage/pull/40017](https://github.com/sagemath/sage/pull/40017)
<img src="../../files/sagemath/PR.png" width="800"/>

<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

### Plan
- Wait. <img src="../../files/sagemath/clock.png" width="200"/>
- Make some other idea for improvements for SageMath.


<img src="../../files/sagemath/line.png" width="800"/>

<br><br>

<img src="../../files/sagemath/thanku.png" width="800"/>