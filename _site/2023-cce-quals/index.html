<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>2023 Cce Quals</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.4" />
<meta property="og:title" content="2023 Cce Quals" />
<meta name="author" content="김민순" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="With Team “02vs04”" />
<meta property="og:description" content="With Team “02vs04”" />
<link rel="canonical" href="http://localhost:4000/2023-cce-quals/" />
<meta property="og:url" content="http://localhost:4000/2023-cce-quals/" />
<meta property="og:site_name" content="I’m such a good surfer" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-06-10T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="2023 Cce Quals" />
<script type="application/ld+json">
{"description":"With Team “02vs04”","url":"http://localhost:4000/2023-cce-quals/","@type":"BlogPosting","headline":"2023 Cce Quals","dateModified":"2023-06-10T00:00:00+09:00","datePublished":"2023-06-10T00:00:00+09:00","author":{"@type":"Person","name":"김민순"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023-cce-quals/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="I&apos;m such a good surfer" /><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$'] ],
    processEscapes: true,
  }
});
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
</script>


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head>
<body a="dark">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">cd ..</a><article>
  <p class="post-meta">
    <font size="2em">soon_haari</font>
    <time datetime="2023-06-10 00:00:00 +0900">2023-06-10</time>
  </p>
  
  <h1>2023 Cce Quals</h1>

  <p>With Team “02vs04”</p>

<p><br /><br /></p>

<h2 id="crypto---wrong-implementation">crypto - Wrong Implementation</h2>

<p>먼저 Message를 알고 Encrypt에 의해 xor되는 정보는 동일하기 때문에 두 ciphertext를 xor하고 Message를 xor해주면 플래그의 뒷부분을 얻을 수 있다.</p>

<p>그리고 보면 key가 7자리 자연수의 str + ABCDEFABC로 고정되어 있기 때문에 가능한 key의 수가 9000000개밖에 존재하지 않는다. 충분히 전수조사를 통해 올바른 키를 구할 수 있다.</p>

<h3 id="expy">ex.py</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">Crypto.Util.Padding</span> <span class="kn">import</span> <span class="n">pad</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">trange</span>

<span class="n">enc_msg</span> <span class="o">=</span>  <span class="mi">31214112203883461538912621847140725647435826042420979977417027226834401610883458792474503120620360328700798549521671</span>
<span class="n">enc_flag</span> <span class="o">=</span> <span class="mi">31214112203883461538912621847140725647435727300325983746492013560576717160853375226573567873228174306246287909482836</span>

<span class="n">flag_2</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"2980625bbcfa2f2958da}"</span>

<span class="n">Message</span> <span class="o">=</span> <span class="s">"Hello, Alice!. My flag is here."</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>

<span class="n">enc_msg</span> <span class="o">=</span> <span class="n">long_to_bytes</span><span class="p">(</span><span class="n">enc_msg</span><span class="p">)</span>




<span class="n">enc</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">enc_msg</span><span class="p">,</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span> <span class="o">*</span> <span class="mi">17</span> <span class="o">+</span> <span class="n">Message</span><span class="p">)</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="s">"ABCDEFABC"</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span>

    <span class="n">Cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Cipher</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">enc</span><span class="p">[</span><span class="o">-</span><span class="mi">16</span><span class="p">:])))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

<span class="sa">b</span><span class="s">'cce2023{a80107b0ac3bc0000000000000000</span><span class="se">\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b</span><span class="s">'</span>

<span class="s">"cce2023{a80107b0ac3bc2980625bbcfa2f2958da}"</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="crypto---the-miracle">crypto - The miracle</h2>

<p>제약 조건이 몇 존재한다.</p>

<p>N은 p * q로 표현되면서 십진수 표현에 약 250비트 가량의 문자열이 포함되어 있어야 한다. (문제 설명에는 앞쪽에 있어야 한다고 되어있는데 중간에 있어도 된다. 근데 앞쪽이 편하다.)</p>

<p>e 또한 250비트 가량의 문자열이 포함되어야 하며, 절댓값이 너무 작은 경우는 배제된다.</p>

<p>p, q가 512비트이기에 다행히 제약 250비트가 큰 문제가 되지 않는다. 500비트가 넘어가면 살짝은 귀찮아졌을지도 모른다. 조건을 만족하는 n을 구하는 방법은 필요한 135글자(250비트) 뒤에 많은 0을 붙여 주어서 <code class="language-plaintext highlighter-rouge">p*q</code>로 표현 가능한 범위인 1023비트 ~ 1024비트가 되게 만들어준다.</p>

<p>근데 10씩 곱해주다 보니 1023, 1024를 점프해서 필요 스트링 앞에 숫자를 하나 더 넣어주었다. 이를 n_base라고 하자. 그리고 소수 p를 고르고 $\left\lfloor n_base / p \right\rfloor$의 값에서 소수가 될때까지 1을 더해주면 좋은 pq쌍을 구할 수 있다.</p>

<p><br /></p>

<p>이 문제의 핵심은 e를 p-1의 배수가 되게 만들어 pow 후의 결과가 p의 배수가 되게 만드는 것이다. Pow한 결과에서 128비트만을 숨겨놨기 때문에 LLL을 통해서 쉽게 복구할 수 있을 것으로 보인다.</p>

<h3 id="exsage">ex.sage</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"20.196.200.237"</span><span class="p">,</span> <span class="mi">2580</span><span class="p">)</span>

<span class="n">n_pfx</span> <span class="o">=</span> <span class="mi">12718281828459045235360287471352662497757247093699959574966967627724076630353</span>
<span class="n">e_pfx</span> <span class="o">=</span> <span class="mi">3141592653589793238462643383279502884197169399375105820974944592307816406286</span>

<span class="n">p</span> <span class="o">=</span> <span class="mi">10472248798148684305914511700419339800175397042519524432660853347874909276697824401438766832062766929661304904284940008789941041544806678388614572567643171</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">12144747583448763569821639376537564467149289084421268874590213062689120295781217102298952495518391037726796906494519998213441943865561185014687044471066047</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">e_pfx</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="mi">200</span>

<span class="n">e</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">e</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">assert</span> <span class="n">e</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="n">test</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">128</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">pow</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="n">test</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"First Outputs</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">bit_length</span><span class="p">())</span>

<span class="n">weight</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">1024</span>

<span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">weight</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">896</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">M</span><span class="p">).</span><span class="n">LLL</span><span class="p">()</span>



<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">M</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">weight</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">bit_length</span><span class="p">())</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="mi">896</span> <span class="o">+</span> <span class="n">res</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="n">b</span>

<span class="n">next_z</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">next_out</span> <span class="o">=</span> <span class="n">next_z</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">896</span><span class="p">)</span>
<span class="n">next_state</span> <span class="o">=</span> <span class="n">next_z</span> <span class="o">&gt;&gt;</span> <span class="mi">896</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">next_out</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">next_state</span><span class="p">))</span>


<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="crypto---nzk-siark">crypto - NZK-SIARK</h2>

<p>필자의 코드가 수많은 반복과 난독화로 인해 400줄인 관계로 부득이하게 풀이과정만 작성하도록 하겠다.</p>

<p>먼저 모든 연산은 8비트의 엔트로피를 가진 GF(2) polynomial ring 위에서 정의되어 있다. 크게 중요하지는 않다. 가장 중요한 부분은 get_sbox_and_verify에서 허용되는 값의 종류가 x가 1 ~ 255면 1/x로 제한되지만, x=0일때는 256개의 값이 모두 들어갈 수 있다.</p>

<p>내부에서 귀찮은 연산을 진행하지만 천만다행히도 모두 일대일 대응이기 때문에 원하는 256개의 값을 모두 조작할 수 있다는 사실에서 시작한다.</p>

<p><br /></p>

<p>키를 입력받고 round key generation은 전 round key를 get_sbox_and verify에 넣어서 조작된다. 
위에서 설명했듯이 255가지는 입력할 수 있는 값이 하나밖에 없지만, 0일 경우만은 원하는 값을 넣을 수 있기 때문에 key에서 4바이트만은 다음에 쓰기 위해 0으로 고정시켜두고 12바이트를 맘대로 조작할 수 있다.</p>

<p>Substitution 또한 get_sbox_and_verify함수를 이용해서 진행된다. 함수에 들어가기 전에 0을 가지고 있으면 또 임의의 조작이 가능하다는 뜻이다.</p>

<p>위에서 초기 키에서 12바이트를 맘대로 고를 수 있다고 했는데 그러면 처음으로 sub를 진행하기 전에 0이 12번 등장하게 설정해줄 수 있다. 그러면 state의 16바이트 중 12바이트가 자유로워진다.</p>

<p>벌써 필요한 자유도가 16바이트인데 12바이트에다가 다음 keygen을 할때 넣을 4바이트까지 해서 16바이트의 자유도가 완성됐다. 목표는 라운드를 질질 끌지 않고 두 번째 sbox에 들어갈 때는 state의 16바이트가 모두 0인것이다. 이게 가능하면 복호화 연산을 통해 ciphertext를 만드는 state의 16바이트를 맘대로 설정할 수 있다.</p>

<p><br /></p>

<p>이제 슬프게도 shift_row, Mix column을 뚫고 어떻게 0 12바이트를 만들 수 있을지에 대한 고찰이 필요하다.</p>

<p>첫 add round key 이후에는 123번째 column이 0벡터, 4번째 column이 고정된 벡터이다. 이를 row shift하면 왼쪽아래 – 오른쪽위를 잇는 대각선에만 0이 아닌 값이 존재하게 된다.</p>

<p>Mix column과정을 봐보면 이제는 선형대수학이 등장할 차례이다. 주어진 mat에 대각선이 고정된 matrix를 곱해서 두번째 키쌍이랑 같은 결과가 나와야 한다. 다시 키 생성과정에 집중하는 것이 포인트이다. 첫 column을 f라고 하면 2, 3, 4번째 column은 f + constant로 표현된다. 즉 지금 사용할 Key matrix는 F + K꼴로 표현가능하다(F = [f, f, f, f], K는 상수).</p>

<p>Mat의 역행렬을 좌측해 곱하고 mat-1K를 양변에서 빼주면 아직도 좌변은 대각선만 고정이고, 우변은 mat-1F이다. 근데 F의 column들이 다 같으니깐 고정된 대각선의 값 4개를 한 벡터로 바꿔서 a = mat-1f의 예쁜 식을 구할 수 있다. <code class="language-plaintext highlighter-rouge">Mat*a = f</code>가 되므로 f벡터를 성공적으로 구할 수 있다. 이제 이 시나리오를 구현하는 건 다른 문제이다. 정말 오래 걸렸다.</p>

<p><br /><br /><br /></p>

<p>[+]</p>

<p>그냥 처음에 16바이트의 키를 입력할 때 16바이트가 전부 같게 설정하면 해결되는 문제였다. 너무 어렵게 돌아가서 풀었다.</p>

<p>필자 빼고는 아무도 이렇게 푼 사람이 없을 것으로 보인다.</p>

<p><img src="../files/cce/image.png" width="250" height="350" /></p>


</article>


      </div>
    </main>
  </body>
</html>